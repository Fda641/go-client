/*
 * Onshape REST API
 *
 * The Onshape REST API consumed by all clients.
 *
 * API version: 1.113
 * Contact: api-support@onshape.zendesk.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package onshape

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// DefaultApiService DefaultApi service
type DefaultApiService service

type apiCreateWorkflowableTestObjectRequest struct {
	ctx _context.Context
	apiService *DefaultApiService
	wfid string
}


/*
CreateWorkflowableTestObject Method for CreateWorkflowableTestObject
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param wfid
@return apiCreateWorkflowableTestObjectRequest
*/
func (a *DefaultApiService) CreateWorkflowableTestObject(ctx _context.Context, wfid string) apiCreateWorkflowableTestObjectRequest {
	return apiCreateWorkflowableTestObjectRequest{
		apiService: a,
		ctx: ctx,
		wfid: wfid,
	}
}

/*
Execute executes the request
 @return BTWorkflowableTestObjectInfo
*/
func (r apiCreateWorkflowableTestObjectRequest) Execute() (BTWorkflowableTestObjectInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTWorkflowableTestObjectInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateWorkflowableTestObject")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/workflowabletestobject/testobject/{wfid}"
	localVarPath = strings.Replace(localVarPath, "{"+"wfid"+"}", _neturl.QueryEscape(parameterToString(r.wfid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTWorkflowableTestObjectInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiDeleteAssociativeDataRequest struct {
	ctx _context.Context
	apiService *DefaultApiService
	did string
	eid string
	wvm string
	wvmid string
	transactionId *string
	parentChangeId *string
	associativeDataId *[]string
	elementId *string
	viewId *string
	microversionId *string
	documentMicroversion *string
	deterministicId *string
	featureId *string
	entityId *string
	occurrenceId *string
}


func (r apiDeleteAssociativeDataRequest) TransactionId(transactionId string) apiDeleteAssociativeDataRequest {
	r.transactionId = &transactionId
	return r
}

func (r apiDeleteAssociativeDataRequest) ParentChangeId(parentChangeId string) apiDeleteAssociativeDataRequest {
	r.parentChangeId = &parentChangeId
	return r
}

func (r apiDeleteAssociativeDataRequest) AssociativeDataId(associativeDataId []string) apiDeleteAssociativeDataRequest {
	r.associativeDataId = &associativeDataId
	return r
}

func (r apiDeleteAssociativeDataRequest) ElementId(elementId string) apiDeleteAssociativeDataRequest {
	r.elementId = &elementId
	return r
}

func (r apiDeleteAssociativeDataRequest) ViewId(viewId string) apiDeleteAssociativeDataRequest {
	r.viewId = &viewId
	return r
}

func (r apiDeleteAssociativeDataRequest) MicroversionId(microversionId string) apiDeleteAssociativeDataRequest {
	r.microversionId = &microversionId
	return r
}

func (r apiDeleteAssociativeDataRequest) DocumentMicroversion(documentMicroversion string) apiDeleteAssociativeDataRequest {
	r.documentMicroversion = &documentMicroversion
	return r
}

func (r apiDeleteAssociativeDataRequest) DeterministicId(deterministicId string) apiDeleteAssociativeDataRequest {
	r.deterministicId = &deterministicId
	return r
}

func (r apiDeleteAssociativeDataRequest) FeatureId(featureId string) apiDeleteAssociativeDataRequest {
	r.featureId = &featureId
	return r
}

func (r apiDeleteAssociativeDataRequest) EntityId(entityId string) apiDeleteAssociativeDataRequest {
	r.entityId = &entityId
	return r
}

func (r apiDeleteAssociativeDataRequest) OccurrenceId(occurrenceId string) apiDeleteAssociativeDataRequest {
	r.occurrenceId = &occurrenceId
	return r
}

/*
DeleteAssociativeData Method for DeleteAssociativeData
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param eid
 * @param wvm
 * @param wvmid
@return apiDeleteAssociativeDataRequest
*/
func (a *DefaultApiService) DeleteAssociativeData(ctx _context.Context, did string, eid string, wvm string, wvmid string) apiDeleteAssociativeDataRequest {
	return apiDeleteAssociativeDataRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		eid: eid,
		wvm: wvm,
		wvmid: wvmid,
	}
}

/*
Execute executes the request
 @return BTAppElementBasicInfo
*/
func (r apiDeleteAssociativeDataRequest) Execute() (BTAppElementBasicInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTAppElementBasicInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteAssociativeData")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/associativedata"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(r.wvm, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(r.wvmid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
											
	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.parentChangeId != nil {
		localVarQueryParams.Add("parentChangeId", parameterToString(*r.parentChangeId, ""))
	}
	if r.associativeDataId != nil {
		t := *r.associativeDataId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("associativeDataId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("associativeDataId", parameterToString(t, "multi"))
		}
	}
	if r.elementId != nil {
		localVarQueryParams.Add("elementId", parameterToString(*r.elementId, ""))
	}
	if r.viewId != nil {
		localVarQueryParams.Add("viewId", parameterToString(*r.viewId, ""))
	}
	if r.microversionId != nil {
		localVarQueryParams.Add("microversionId", parameterToString(*r.microversionId, ""))
	}
	if r.documentMicroversion != nil {
		localVarQueryParams.Add("documentMicroversion", parameterToString(*r.documentMicroversion, ""))
	}
	if r.deterministicId != nil {
		localVarQueryParams.Add("deterministicId", parameterToString(*r.deterministicId, ""))
	}
	if r.featureId != nil {
		localVarQueryParams.Add("featureId", parameterToString(*r.featureId, ""))
	}
	if r.entityId != nil {
		localVarQueryParams.Add("entityId", parameterToString(*r.entityId, ""))
	}
	if r.occurrenceId != nil {
		localVarQueryParams.Add("occurrenceId", parameterToString(*r.occurrenceId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTAppElementBasicInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiGetAssociativeDataRequest struct {
	ctx _context.Context
	apiService *DefaultApiService
	did string
	wvm string
	wvmid string
	eid string
	transactionId *string
	changeId *string
	associativeDataId *[]string
	elementId *string
	viewId *string
	microversionId *string
	documentMicroversion *string
	deterministicId *string
	featureId *string
	entityId *string
	occurrenceId *string
	returnIdTags *bool
}


func (r apiGetAssociativeDataRequest) TransactionId(transactionId string) apiGetAssociativeDataRequest {
	r.transactionId = &transactionId
	return r
}

func (r apiGetAssociativeDataRequest) ChangeId(changeId string) apiGetAssociativeDataRequest {
	r.changeId = &changeId
	return r
}

func (r apiGetAssociativeDataRequest) AssociativeDataId(associativeDataId []string) apiGetAssociativeDataRequest {
	r.associativeDataId = &associativeDataId
	return r
}

func (r apiGetAssociativeDataRequest) ElementId(elementId string) apiGetAssociativeDataRequest {
	r.elementId = &elementId
	return r
}

func (r apiGetAssociativeDataRequest) ViewId(viewId string) apiGetAssociativeDataRequest {
	r.viewId = &viewId
	return r
}

func (r apiGetAssociativeDataRequest) MicroversionId(microversionId string) apiGetAssociativeDataRequest {
	r.microversionId = &microversionId
	return r
}

func (r apiGetAssociativeDataRequest) DocumentMicroversion(documentMicroversion string) apiGetAssociativeDataRequest {
	r.documentMicroversion = &documentMicroversion
	return r
}

func (r apiGetAssociativeDataRequest) DeterministicId(deterministicId string) apiGetAssociativeDataRequest {
	r.deterministicId = &deterministicId
	return r
}

func (r apiGetAssociativeDataRequest) FeatureId(featureId string) apiGetAssociativeDataRequest {
	r.featureId = &featureId
	return r
}

func (r apiGetAssociativeDataRequest) EntityId(entityId string) apiGetAssociativeDataRequest {
	r.entityId = &entityId
	return r
}

func (r apiGetAssociativeDataRequest) OccurrenceId(occurrenceId string) apiGetAssociativeDataRequest {
	r.occurrenceId = &occurrenceId
	return r
}

func (r apiGetAssociativeDataRequest) ReturnIdTags(returnIdTags bool) apiGetAssociativeDataRequest {
	r.returnIdTags = &returnIdTags
	return r
}

/*
GetAssociativeData Method for GetAssociativeData
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
@return apiGetAssociativeDataRequest
*/
func (a *DefaultApiService) GetAssociativeData(ctx _context.Context, did string, wvm string, wvmid string, eid string) apiGetAssociativeDataRequest {
	return apiGetAssociativeDataRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wvm: wvm,
		wvmid: wvmid,
		eid: eid,
	}
}

/*
Execute executes the request
 @return BTAppAssociativeDataInfoArray
*/
func (r apiGetAssociativeDataRequest) Execute() (BTAppAssociativeDataInfoArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTAppAssociativeDataInfoArray
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAssociativeData")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/associativedata"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(r.wvm, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(r.wvmid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
												
	if r.transactionId != nil {
		localVarQueryParams.Add("transactionId", parameterToString(*r.transactionId, ""))
	}
	if r.changeId != nil {
		localVarQueryParams.Add("changeId", parameterToString(*r.changeId, ""))
	}
	if r.associativeDataId != nil {
		t := *r.associativeDataId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("associativeDataId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("associativeDataId", parameterToString(t, "multi"))
		}
	}
	if r.elementId != nil {
		localVarQueryParams.Add("elementId", parameterToString(*r.elementId, ""))
	}
	if r.viewId != nil {
		localVarQueryParams.Add("viewId", parameterToString(*r.viewId, ""))
	}
	if r.microversionId != nil {
		localVarQueryParams.Add("microversionId", parameterToString(*r.microversionId, ""))
	}
	if r.documentMicroversion != nil {
		localVarQueryParams.Add("documentMicroversion", parameterToString(*r.documentMicroversion, ""))
	}
	if r.deterministicId != nil {
		localVarQueryParams.Add("deterministicId", parameterToString(*r.deterministicId, ""))
	}
	if r.featureId != nil {
		localVarQueryParams.Add("featureId", parameterToString(*r.featureId, ""))
	}
	if r.entityId != nil {
		localVarQueryParams.Add("entityId", parameterToString(*r.entityId, ""))
	}
	if r.occurrenceId != nil {
		localVarQueryParams.Add("occurrenceId", parameterToString(*r.occurrenceId, ""))
	}
	if r.returnIdTags != nil {
		localVarQueryParams.Add("returnIdTags", parameterToString(*r.returnIdTags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTAppAssociativeDataInfoArray
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiGetLatestInDocumentRequest struct {
	ctx _context.Context
	apiService *DefaultApiService
	did string
	betaCapabilityIds *[]string
	includeParts *bool
	includeSurfaces *bool
	includeWires *bool
	includeSketches *bool
	includeReferenceFeatures *bool
	includeAssemblies *bool
	includeFeatures *bool
	includeFeatureStudios *bool
	includePartStudios *bool
	includeBlobs *bool
	includeMeshes *bool
	includeFlattenedBodies *bool
	allowedBlobMimeTypes *string
	maxFeatureScriptVersion *int32
	includeApplications *bool
	allowedApplicationMimeTypes *string
	includeCompositeParts *bool
	includeFSTables *bool
}


func (r apiGetLatestInDocumentRequest) BetaCapabilityIds(betaCapabilityIds []string) apiGetLatestInDocumentRequest {
	r.betaCapabilityIds = &betaCapabilityIds
	return r
}

func (r apiGetLatestInDocumentRequest) IncludeParts(includeParts bool) apiGetLatestInDocumentRequest {
	r.includeParts = &includeParts
	return r
}

func (r apiGetLatestInDocumentRequest) IncludeSurfaces(includeSurfaces bool) apiGetLatestInDocumentRequest {
	r.includeSurfaces = &includeSurfaces
	return r
}

func (r apiGetLatestInDocumentRequest) IncludeWires(includeWires bool) apiGetLatestInDocumentRequest {
	r.includeWires = &includeWires
	return r
}

func (r apiGetLatestInDocumentRequest) IncludeSketches(includeSketches bool) apiGetLatestInDocumentRequest {
	r.includeSketches = &includeSketches
	return r
}

func (r apiGetLatestInDocumentRequest) IncludeReferenceFeatures(includeReferenceFeatures bool) apiGetLatestInDocumentRequest {
	r.includeReferenceFeatures = &includeReferenceFeatures
	return r
}

func (r apiGetLatestInDocumentRequest) IncludeAssemblies(includeAssemblies bool) apiGetLatestInDocumentRequest {
	r.includeAssemblies = &includeAssemblies
	return r
}

func (r apiGetLatestInDocumentRequest) IncludeFeatures(includeFeatures bool) apiGetLatestInDocumentRequest {
	r.includeFeatures = &includeFeatures
	return r
}

func (r apiGetLatestInDocumentRequest) IncludeFeatureStudios(includeFeatureStudios bool) apiGetLatestInDocumentRequest {
	r.includeFeatureStudios = &includeFeatureStudios
	return r
}

func (r apiGetLatestInDocumentRequest) IncludePartStudios(includePartStudios bool) apiGetLatestInDocumentRequest {
	r.includePartStudios = &includePartStudios
	return r
}

func (r apiGetLatestInDocumentRequest) IncludeBlobs(includeBlobs bool) apiGetLatestInDocumentRequest {
	r.includeBlobs = &includeBlobs
	return r
}

func (r apiGetLatestInDocumentRequest) IncludeMeshes(includeMeshes bool) apiGetLatestInDocumentRequest {
	r.includeMeshes = &includeMeshes
	return r
}

func (r apiGetLatestInDocumentRequest) IncludeFlattenedBodies(includeFlattenedBodies bool) apiGetLatestInDocumentRequest {
	r.includeFlattenedBodies = &includeFlattenedBodies
	return r
}

func (r apiGetLatestInDocumentRequest) AllowedBlobMimeTypes(allowedBlobMimeTypes string) apiGetLatestInDocumentRequest {
	r.allowedBlobMimeTypes = &allowedBlobMimeTypes
	return r
}

func (r apiGetLatestInDocumentRequest) MaxFeatureScriptVersion(maxFeatureScriptVersion int32) apiGetLatestInDocumentRequest {
	r.maxFeatureScriptVersion = &maxFeatureScriptVersion
	return r
}

func (r apiGetLatestInDocumentRequest) IncludeApplications(includeApplications bool) apiGetLatestInDocumentRequest {
	r.includeApplications = &includeApplications
	return r
}

func (r apiGetLatestInDocumentRequest) AllowedApplicationMimeTypes(allowedApplicationMimeTypes string) apiGetLatestInDocumentRequest {
	r.allowedApplicationMimeTypes = &allowedApplicationMimeTypes
	return r
}

func (r apiGetLatestInDocumentRequest) IncludeCompositeParts(includeCompositeParts bool) apiGetLatestInDocumentRequest {
	r.includeCompositeParts = &includeCompositeParts
	return r
}

func (r apiGetLatestInDocumentRequest) IncludeFSTables(includeFSTables bool) apiGetLatestInDocumentRequest {
	r.includeFSTables = &includeFSTables
	return r
}

/*
GetLatestInDocument insertables for a document
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
@return apiGetLatestInDocumentRequest
*/
func (a *DefaultApiService) GetLatestInDocument(ctx _context.Context, did string) apiGetLatestInDocumentRequest {
	return apiGetLatestInDocumentRequest{
		apiService: a,
		ctx: ctx,
		did: did,
	}
}

/*
Execute executes the request
 @return BTListResponseBTInsertableInfo
*/
func (r apiGetLatestInDocumentRequest) Execute() (BTListResponseBTInsertableInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTListResponseBTInsertableInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetLatestInDocument")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/insertables/d/{did}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
																			
	if r.betaCapabilityIds != nil {
		t := *r.betaCapabilityIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("betaCapabilityIds", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("betaCapabilityIds", parameterToString(t, "multi"))
		}
	}
	if r.includeParts != nil {
		localVarQueryParams.Add("includeParts", parameterToString(*r.includeParts, ""))
	}
	if r.includeSurfaces != nil {
		localVarQueryParams.Add("includeSurfaces", parameterToString(*r.includeSurfaces, ""))
	}
	if r.includeWires != nil {
		localVarQueryParams.Add("includeWires", parameterToString(*r.includeWires, ""))
	}
	if r.includeSketches != nil {
		localVarQueryParams.Add("includeSketches", parameterToString(*r.includeSketches, ""))
	}
	if r.includeReferenceFeatures != nil {
		localVarQueryParams.Add("includeReferenceFeatures", parameterToString(*r.includeReferenceFeatures, ""))
	}
	if r.includeAssemblies != nil {
		localVarQueryParams.Add("includeAssemblies", parameterToString(*r.includeAssemblies, ""))
	}
	if r.includeFeatures != nil {
		localVarQueryParams.Add("includeFeatures", parameterToString(*r.includeFeatures, ""))
	}
	if r.includeFeatureStudios != nil {
		localVarQueryParams.Add("includeFeatureStudios", parameterToString(*r.includeFeatureStudios, ""))
	}
	if r.includePartStudios != nil {
		localVarQueryParams.Add("includePartStudios", parameterToString(*r.includePartStudios, ""))
	}
	if r.includeBlobs != nil {
		localVarQueryParams.Add("includeBlobs", parameterToString(*r.includeBlobs, ""))
	}
	if r.includeMeshes != nil {
		localVarQueryParams.Add("includeMeshes", parameterToString(*r.includeMeshes, ""))
	}
	if r.includeFlattenedBodies != nil {
		localVarQueryParams.Add("includeFlattenedBodies", parameterToString(*r.includeFlattenedBodies, ""))
	}
	if r.allowedBlobMimeTypes != nil {
		localVarQueryParams.Add("allowedBlobMimeTypes", parameterToString(*r.allowedBlobMimeTypes, ""))
	}
	if r.maxFeatureScriptVersion != nil {
		localVarQueryParams.Add("maxFeatureScriptVersion", parameterToString(*r.maxFeatureScriptVersion, ""))
	}
	if r.includeApplications != nil {
		localVarQueryParams.Add("includeApplications", parameterToString(*r.includeApplications, ""))
	}
	if r.allowedApplicationMimeTypes != nil {
		localVarQueryParams.Add("allowedApplicationMimeTypes", parameterToString(*r.allowedApplicationMimeTypes, ""))
	}
	if r.includeCompositeParts != nil {
		localVarQueryParams.Add("includeCompositeParts", parameterToString(*r.includeCompositeParts, ""))
	}
	if r.includeFSTables != nil {
		localVarQueryParams.Add("includeFSTables", parameterToString(*r.includeFSTables, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTListResponseBTInsertableInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiGetMetadataSchemaRequest struct {
	ctx _context.Context
	apiService *DefaultApiService
	objectType *int32
	ownerId *string
	documentId *string
	ownerType *int32
}


func (r apiGetMetadataSchemaRequest) ObjectType(objectType int32) apiGetMetadataSchemaRequest {
	r.objectType = &objectType
	return r
}

func (r apiGetMetadataSchemaRequest) OwnerId(ownerId string) apiGetMetadataSchemaRequest {
	r.ownerId = &ownerId
	return r
}

func (r apiGetMetadataSchemaRequest) DocumentId(documentId string) apiGetMetadataSchemaRequest {
	r.documentId = &documentId
	return r
}

func (r apiGetMetadataSchemaRequest) OwnerType(ownerType int32) apiGetMetadataSchemaRequest {
	r.ownerType = &ownerType
	return r
}

/*
GetMetadataSchema Method for GetMetadataSchema
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetMetadataSchemaRequest
*/
func (a *DefaultApiService) GetMetadataSchema(ctx _context.Context) apiGetMetadataSchemaRequest {
	return apiGetMetadataSchemaRequest{
		apiService: a,
		ctx: ctx,
	}
}

/*
Execute executes the request
 @return BTMetadataSchemaInfo
*/
func (r apiGetMetadataSchemaRequest) Execute() (BTMetadataSchemaInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTMetadataSchemaInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetMetadataSchema")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/metadataschema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	if r.objectType == nil {
		return localVarReturnValue, nil, reportError("objectType is required and must be specified")
	}
			
	if r.ownerId != nil {
		localVarQueryParams.Add("ownerId", parameterToString(*r.ownerId, ""))
	}
	if r.documentId != nil {
		localVarQueryParams.Add("documentId", parameterToString(*r.documentId, ""))
	}
	if r.ownerType != nil {
		localVarQueryParams.Add("ownerType", parameterToString(*r.ownerType, ""))
	}
	localVarQueryParams.Add("objectType", parameterToString(*r.objectType, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTMetadataSchemaInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiGetPropertiesRequest struct {
	ctx _context.Context
	apiService *DefaultApiService
	schemaId *string
	ownerId *string
	documentId *string
	ownerType *int32
	objectType *int32
	strict *bool
	activeOnly *bool
	offset *int32
	limit *int32
}


func (r apiGetPropertiesRequest) SchemaId(schemaId string) apiGetPropertiesRequest {
	r.schemaId = &schemaId
	return r
}

func (r apiGetPropertiesRequest) OwnerId(ownerId string) apiGetPropertiesRequest {
	r.ownerId = &ownerId
	return r
}

func (r apiGetPropertiesRequest) DocumentId(documentId string) apiGetPropertiesRequest {
	r.documentId = &documentId
	return r
}

func (r apiGetPropertiesRequest) OwnerType(ownerType int32) apiGetPropertiesRequest {
	r.ownerType = &ownerType
	return r
}

func (r apiGetPropertiesRequest) ObjectType(objectType int32) apiGetPropertiesRequest {
	r.objectType = &objectType
	return r
}

func (r apiGetPropertiesRequest) Strict(strict bool) apiGetPropertiesRequest {
	r.strict = &strict
	return r
}

func (r apiGetPropertiesRequest) ActiveOnly(activeOnly bool) apiGetPropertiesRequest {
	r.activeOnly = &activeOnly
	return r
}

func (r apiGetPropertiesRequest) Offset(offset int32) apiGetPropertiesRequest {
	r.offset = &offset
	return r
}

func (r apiGetPropertiesRequest) Limit(limit int32) apiGetPropertiesRequest {
	r.limit = &limit
	return r
}

/*
GetProperties Method for GetProperties
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetPropertiesRequest
*/
func (a *DefaultApiService) GetProperties(ctx _context.Context) apiGetPropertiesRequest {
	return apiGetPropertiesRequest{
		apiService: a,
		ctx: ctx,
	}
}

/*
Execute executes the request
 @return BTListResponseBTMetadataPropertySummaryInfo
*/
func (r apiGetPropertiesRequest) Execute() (BTListResponseBTMetadataPropertySummaryInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTListResponseBTMetadataPropertySummaryInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetProperties")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/metadataschema/properties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
									
	if r.schemaId != nil {
		localVarQueryParams.Add("schemaId", parameterToString(*r.schemaId, ""))
	}
	if r.ownerId != nil {
		localVarQueryParams.Add("ownerId", parameterToString(*r.ownerId, ""))
	}
	if r.documentId != nil {
		localVarQueryParams.Add("documentId", parameterToString(*r.documentId, ""))
	}
	if r.ownerType != nil {
		localVarQueryParams.Add("ownerType", parameterToString(*r.ownerType, ""))
	}
	if r.objectType != nil {
		localVarQueryParams.Add("objectType", parameterToString(*r.objectType, ""))
	}
	if r.strict != nil {
		localVarQueryParams.Add("strict", parameterToString(*r.strict, ""))
	}
	if r.activeOnly != nil {
		localVarQueryParams.Add("activeOnly", parameterToString(*r.activeOnly, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTListResponseBTMetadataPropertySummaryInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiGetPropertyInfoRequest struct {
	ctx _context.Context
	apiService *DefaultApiService
	pid string
	documentId *string
	schemaId *string
	ownerId *string
	ownerType *int32
	objectType *int32
}


func (r apiGetPropertyInfoRequest) DocumentId(documentId string) apiGetPropertyInfoRequest {
	r.documentId = &documentId
	return r
}

func (r apiGetPropertyInfoRequest) SchemaId(schemaId string) apiGetPropertyInfoRequest {
	r.schemaId = &schemaId
	return r
}

func (r apiGetPropertyInfoRequest) OwnerId(ownerId string) apiGetPropertyInfoRequest {
	r.ownerId = &ownerId
	return r
}

func (r apiGetPropertyInfoRequest) OwnerType(ownerType int32) apiGetPropertyInfoRequest {
	r.ownerType = &ownerType
	return r
}

func (r apiGetPropertyInfoRequest) ObjectType(objectType int32) apiGetPropertyInfoRequest {
	r.objectType = &objectType
	return r
}

/*
GetPropertyInfo Method for GetPropertyInfo
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pid
@return apiGetPropertyInfoRequest
*/
func (a *DefaultApiService) GetPropertyInfo(ctx _context.Context, pid string) apiGetPropertyInfoRequest {
	return apiGetPropertyInfoRequest{
		apiService: a,
		ctx: ctx,
		pid: pid,
	}
}

/*
Execute executes the request
 @return BTMetadataPropertyInfo
*/
func (r apiGetPropertyInfoRequest) Execute() (BTMetadataPropertyInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTMetadataPropertyInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPropertyInfo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/metadataschema/propertyinfo/{pid}"
	localVarPath = strings.Replace(localVarPath, "{"+"pid"+"}", _neturl.QueryEscape(parameterToString(r.pid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
					
	if r.documentId != nil {
		localVarQueryParams.Add("documentId", parameterToString(*r.documentId, ""))
	}
	if r.schemaId != nil {
		localVarQueryParams.Add("schemaId", parameterToString(*r.schemaId, ""))
	}
	if r.ownerId != nil {
		localVarQueryParams.Add("ownerId", parameterToString(*r.ownerId, ""))
	}
	if r.ownerType != nil {
		localVarQueryParams.Add("ownerType", parameterToString(*r.ownerType, ""))
	}
	if r.objectType != nil {
		localVarQueryParams.Add("objectType", parameterToString(*r.objectType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTMetadataPropertyInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiGetSchemaRequest struct {
	ctx _context.Context
	apiService *DefaultApiService
	sid string
	documentId *string
}


func (r apiGetSchemaRequest) DocumentId(documentId string) apiGetSchemaRequest {
	r.documentId = &documentId
	return r
}

/*
GetSchema Method for GetSchema
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param sid
@return apiGetSchemaRequest
*/
func (a *DefaultApiService) GetSchema(ctx _context.Context, sid string) apiGetSchemaRequest {
	return apiGetSchemaRequest{
		apiService: a,
		ctx: ctx,
		sid: sid,
	}
}

/*
Execute executes the request
 @return BTMetadataSchemaInfo
*/
func (r apiGetSchemaRequest) Execute() (BTMetadataSchemaInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTMetadataSchemaInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSchema")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/metadataschema/{sid}"
	localVarPath = strings.Replace(localVarPath, "{"+"sid"+"}", _neturl.QueryEscape(parameterToString(r.sid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	if r.documentId != nil {
		localVarQueryParams.Add("documentId", parameterToString(*r.documentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTMetadataSchemaInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiGetSketchBoundingBoxesRequest struct {
	ctx _context.Context
	apiService *DefaultApiService
	did string
	wvm string
	wvmid string
	eid string
	sid string
	configuration *string
	linkDocumentId *string
}


func (r apiGetSketchBoundingBoxesRequest) Configuration(configuration string) apiGetSketchBoundingBoxesRequest {
	r.configuration = &configuration
	return r
}

func (r apiGetSketchBoundingBoxesRequest) LinkDocumentId(linkDocumentId string) apiGetSketchBoundingBoxesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

/*
GetSketchBoundingBoxes Method for GetSketchBoundingBoxes
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
 * @param sid
@return apiGetSketchBoundingBoxesRequest
*/
func (a *DefaultApiService) GetSketchBoundingBoxes(ctx _context.Context, did string, wvm string, wvmid string, eid string, sid string) apiGetSketchBoundingBoxesRequest {
	return apiGetSketchBoundingBoxesRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wvm: wvm,
		wvmid: wvmid,
		eid: eid,
		sid: sid,
	}
}

/*
Execute executes the request
 @return BTBoundingBoxInfo
*/
func (r apiGetSketchBoundingBoxesRequest) Execute() (BTBoundingBoxInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTBoundingBoxInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSketchBoundingBoxes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/sketches/{sid}/boundingboxes"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(r.wvm, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(r.wvmid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sid"+"}", _neturl.QueryEscape(parameterToString(r.sid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
	
		
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTBoundingBoxInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiGetSketchInfoRequest struct {
	ctx _context.Context
	apiService *DefaultApiService
	did string
	wvm string
	wvmid string
	eid string
	configuration *string
	sketchId *[]string
	output3D *bool
	curvePoints *bool
	includeGeometry *bool
	linkDocumentId *string
}


func (r apiGetSketchInfoRequest) Configuration(configuration string) apiGetSketchInfoRequest {
	r.configuration = &configuration
	return r
}

func (r apiGetSketchInfoRequest) SketchId(sketchId []string) apiGetSketchInfoRequest {
	r.sketchId = &sketchId
	return r
}

func (r apiGetSketchInfoRequest) Output3D(output3D bool) apiGetSketchInfoRequest {
	r.output3D = &output3D
	return r
}

func (r apiGetSketchInfoRequest) CurvePoints(curvePoints bool) apiGetSketchInfoRequest {
	r.curvePoints = &curvePoints
	return r
}

func (r apiGetSketchInfoRequest) IncludeGeometry(includeGeometry bool) apiGetSketchInfoRequest {
	r.includeGeometry = &includeGeometry
	return r
}

func (r apiGetSketchInfoRequest) LinkDocumentId(linkDocumentId string) apiGetSketchInfoRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

/*
GetSketchInfo Method for GetSketchInfo
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
@return apiGetSketchInfoRequest
*/
func (a *DefaultApiService) GetSketchInfo(ctx _context.Context, did string, wvm string, wvmid string, eid string) apiGetSketchInfoRequest {
	return apiGetSketchInfoRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wvm: wvm,
		wvmid: wvmid,
		eid: eid,
	}
}

/*
Execute executes the request

*/
func (r apiGetSketchInfoRequest) Execute() (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSketchInfo")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/sketches"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(r.wvm, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(r.wvmid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
						
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.sketchId != nil {
		t := *r.sketchId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sketchId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sketchId", parameterToString(t, "multi"))
		}
	}
	if r.output3D != nil {
		localVarQueryParams.Add("output3D", parameterToString(*r.output3D, ""))
	}
	if r.curvePoints != nil {
		localVarQueryParams.Add("curvePoints", parameterToString(*r.curvePoints, ""))
	}
	if r.includeGeometry != nil {
		localVarQueryParams.Add("includeGeometry", parameterToString(*r.includeGeometry, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
type apiGetTessellatedEntitiesRequest struct {
	ctx _context.Context
	apiService *DefaultApiService
	did string
	wvm string
	wvmid string
	eid string
	sid string
	configuration *string
	entityId *[]string
	angleTolerance *float64
	chordTolerance *float64
	linkDocumentId *string
}


func (r apiGetTessellatedEntitiesRequest) Configuration(configuration string) apiGetTessellatedEntitiesRequest {
	r.configuration = &configuration
	return r
}

func (r apiGetTessellatedEntitiesRequest) EntityId(entityId []string) apiGetTessellatedEntitiesRequest {
	r.entityId = &entityId
	return r
}

func (r apiGetTessellatedEntitiesRequest) AngleTolerance(angleTolerance float64) apiGetTessellatedEntitiesRequest {
	r.angleTolerance = &angleTolerance
	return r
}

func (r apiGetTessellatedEntitiesRequest) ChordTolerance(chordTolerance float64) apiGetTessellatedEntitiesRequest {
	r.chordTolerance = &chordTolerance
	return r
}

func (r apiGetTessellatedEntitiesRequest) LinkDocumentId(linkDocumentId string) apiGetTessellatedEntitiesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

/*
GetTessellatedEntities Method for GetTessellatedEntities
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
 * @param sid
@return apiGetTessellatedEntitiesRequest
*/
func (a *DefaultApiService) GetTessellatedEntities(ctx _context.Context, did string, wvm string, wvmid string, eid string, sid string) apiGetTessellatedEntitiesRequest {
	return apiGetTessellatedEntitiesRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wvm: wvm,
		wvmid: wvmid,
		eid: eid,
		sid: sid,
	}
}

/*
Execute executes the request

*/
func (r apiGetTessellatedEntitiesRequest) Execute() (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTessellatedEntities")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/sketches/{sid}/tessellatedentities"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(r.wvm, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(r.wvmid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sid"+"}", _neturl.QueryEscape(parameterToString(r.sid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
	
					
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.entityId != nil {
		t := *r.entityId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("entityId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("entityId", parameterToString(t, "multi"))
		}
	}
	if r.angleTolerance != nil {
		localVarQueryParams.Add("angleTolerance", parameterToString(*r.angleTolerance, ""))
	}
	if r.chordTolerance != nil {
		localVarQueryParams.Add("chordTolerance", parameterToString(*r.chordTolerance, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
type apiGetWorkflowableTestObjectRequest struct {
	ctx _context.Context
	apiService *DefaultApiService
	oid string
}


/*
GetWorkflowableTestObject Method for GetWorkflowableTestObject
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param oid
@return apiGetWorkflowableTestObjectRequest
*/
func (a *DefaultApiService) GetWorkflowableTestObject(ctx _context.Context, oid string) apiGetWorkflowableTestObjectRequest {
	return apiGetWorkflowableTestObjectRequest{
		apiService: a,
		ctx: ctx,
		oid: oid,
	}
}

/*
Execute executes the request
 @return BTWorkflowableTestObjectInfo
*/
func (r apiGetWorkflowableTestObjectRequest) Execute() (BTWorkflowableTestObjectInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTWorkflowableTestObjectInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetWorkflowableTestObject")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/workflowabletestobject/{oid}"
	localVarPath = strings.Replace(localVarPath, "{"+"oid"+"}", _neturl.QueryEscape(parameterToString(r.oid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTWorkflowableTestObjectInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiPostAssociativeDataRequest struct {
	ctx _context.Context
	apiService *DefaultApiService
	did string
	eid string
	wvm string
	wvmid string
	body *string
}


func (r apiPostAssociativeDataRequest) Body(body string) apiPostAssociativeDataRequest {
	r.body = &body
	return r
}

/*
PostAssociativeData Method for PostAssociativeData
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param eid
 * @param wvm
 * @param wvmid
@return apiPostAssociativeDataRequest
*/
func (a *DefaultApiService) PostAssociativeData(ctx _context.Context, did string, eid string, wvm string, wvmid string) apiPostAssociativeDataRequest {
	return apiPostAssociativeDataRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		eid: eid,
		wvm: wvm,
		wvmid: wvmid,
	}
}

/*
Execute executes the request
 @return BTAppAssociativeDataInfoArray
*/
func (r apiPostAssociativeDataRequest) Execute() (BTAppAssociativeDataInfoArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTAppAssociativeDataInfoArray
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PostAssociativeData")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/associativedata"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(r.wvm, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(r.wvmid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
	
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTAppAssociativeDataInfoArray
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiTransitionWorkflowableTestObjectRequest struct {
	ctx _context.Context
	apiService *DefaultApiService
	oid string
	transition string
}


/*
TransitionWorkflowableTestObject Method for TransitionWorkflowableTestObject
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param oid
 * @param transition
@return apiTransitionWorkflowableTestObjectRequest
*/
func (a *DefaultApiService) TransitionWorkflowableTestObject(ctx _context.Context, oid string, transition string) apiTransitionWorkflowableTestObjectRequest {
	return apiTransitionWorkflowableTestObjectRequest{
		apiService: a,
		ctx: ctx,
		oid: oid,
		transition: transition,
	}
}

/*
Execute executes the request
 @return BTWorkflowableTestObjectInfo
*/
func (r apiTransitionWorkflowableTestObjectRequest) Execute() (BTWorkflowableTestObjectInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTWorkflowableTestObjectInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TransitionWorkflowableTestObject")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/workflowabletestobject/{oid}/{transition}"
	localVarPath = strings.Replace(localVarPath, "{"+"oid"+"}", _neturl.QueryEscape(parameterToString(r.oid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transition"+"}", _neturl.QueryEscape(parameterToString(r.transition, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTWorkflowableTestObjectInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiUpdateWorkflowableTestObjectRequest struct {
	ctx _context.Context
	apiService *DefaultApiService
	oid string
	bTUpdateWorkflowableTestObjectParams *BTUpdateWorkflowableTestObjectParams
}


func (r apiUpdateWorkflowableTestObjectRequest) BTUpdateWorkflowableTestObjectParams(bTUpdateWorkflowableTestObjectParams BTUpdateWorkflowableTestObjectParams) apiUpdateWorkflowableTestObjectRequest {
	r.bTUpdateWorkflowableTestObjectParams = &bTUpdateWorkflowableTestObjectParams
	return r
}

/*
UpdateWorkflowableTestObject Method for UpdateWorkflowableTestObject
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param oid
@return apiUpdateWorkflowableTestObjectRequest
*/
func (a *DefaultApiService) UpdateWorkflowableTestObject(ctx _context.Context, oid string) apiUpdateWorkflowableTestObjectRequest {
	return apiUpdateWorkflowableTestObjectRequest{
		apiService: a,
		ctx: ctx,
		oid: oid,
	}
}

/*
Execute executes the request
 @return BTWorkflowableTestObjectInfo
*/
func (r apiUpdateWorkflowableTestObjectRequest) Execute() (BTWorkflowableTestObjectInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTWorkflowableTestObjectInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateWorkflowableTestObject")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/workflowabletestobject/{oid}"
	localVarPath = strings.Replace(localVarPath, "{"+"oid"+"}", _neturl.QueryEscape(parameterToString(r.oid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	if r.bTUpdateWorkflowableTestObjectParams == nil {
		return localVarReturnValue, nil, reportError("bTUpdateWorkflowableTestObjectParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTUpdateWorkflowableTestObjectParams
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTWorkflowableTestObjectInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
