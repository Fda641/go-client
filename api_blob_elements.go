/*
 * Onshape REST API
 *
 * The Onshape REST API consumed by all clients.
 *
 * API version: 1.111
 * Contact: api-support@onshape.zendesk.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// BlobElementsApiService BlobElementsApi service
type BlobElementsApiService service

/*
CreateBlobTranslation Create Translation.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wv
 * @param wvid
 * @param eid
 * @param btTranslateFormatParams
@return BtTranslationRequestInfo
*/
func (a *BlobElementsApiService) CreateBlobTranslation(ctx _context.Context, did string, wv string, wvid string, eid string, btTranslateFormatParams BtTranslateFormatParams) (BtTranslationRequestInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtTranslationRequestInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/blobelements/d/{did}/{wv}/{wvid}/e/{eid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", _neturl.QueryEscape(parameterToString(wv, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", _neturl.QueryEscape(parameterToString(wvid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &btTranslateFormatParams
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtTranslationRequestInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// DownloadFileWorkspaceOpts Optional parameters for the method 'DownloadFileWorkspace'
type DownloadFileWorkspaceOpts struct {
    ContentDisposition optional.String
    IfNoneMatch optional.String
    LinkDocumentId optional.String
}

/*
DownloadFileWorkspace Download File From Blob Element.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wid
 * @param eid
 * @param optional nil or *DownloadFileWorkspaceOpts - Optional Parameters:
 * @param "ContentDisposition" (optional.String) - 
 * @param "IfNoneMatch" (optional.String) - 
 * @param "LinkDocumentId" (optional.String) - 
@return *os.File
*/
func (a *BlobElementsApiService) DownloadFileWorkspace(ctx _context.Context, did string, wid string, eid string, localVarOptionals *DownloadFileWorkspaceOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/blobelements/d/{did}/w/{wid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(wid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ContentDisposition.IsSet() {
		localVarQueryParams.Add("contentDisposition", parameterToString(localVarOptionals.ContentDisposition.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v *os.File
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
UpdateUnits Update Mesh Units.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param eid
 * @param wid
 * @param btUpdateMeshUnitsParams
@return BtDocumentElementProcessingInfo
*/
func (a *BlobElementsApiService) UpdateUnits(ctx _context.Context, did string, eid string, wid string, btUpdateMeshUnitsParams BtUpdateMeshUnitsParams) (BtDocumentElementProcessingInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtDocumentElementProcessingInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/blobelements/d/{did}/w/{wid}/e/{eid}/units"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(wid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &btUpdateMeshUnitsParams
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtDocumentElementProcessingInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// UploadFileCreateElementOpts Optional parameters for the method 'UploadFileCreateElement'
type UploadFileCreateElementOpts struct {
    AllowFaultyParts optional.Bool
    CreateComposite optional.Bool
    CreateDrawingIfPossible optional.Bool
    EncodedFilename optional.String
    ExtractAssemblyHierarchy optional.Bool
    File optional.Interface
    FileBodyWithDetails optional.Interface
    FileContentLength optional.Int64
    FileDetail optional.Interface
    FlattenAssemblies optional.Bool
    FormatName optional.String
    IsyAxisIsUp optional.Bool
    JoinAdjacentSurfaces optional.Bool
    LocationElementId optional.String
    LocationGroupId optional.String
    LocationPosition optional.Int32
    NotifyUser optional.Bool
    OwnerId optional.String
    OwnerType optional.String
    ParentId optional.String
    ProjectId optional.String
    Public optional.Bool
    SplitAssembliesIntoMultipleDocuments optional.Bool
    StoreInDocument optional.Bool
    Translate optional.Bool
    Unit optional.String
    UploadId optional.String
    VersionString optional.String
}

/*
UploadFileCreateElement Upload file to new element.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wid
 * @param optional nil or *UploadFileCreateElementOpts - Optional Parameters:
 * @param "AllowFaultyParts" (optional.Bool) - 
 * @param "CreateComposite" (optional.Bool) - 
 * @param "CreateDrawingIfPossible" (optional.Bool) - 
 * @param "EncodedFilename" (optional.String) - 
 * @param "ExtractAssemblyHierarchy" (optional.Bool) - 
 * @param "File" (optional.Interface of *os.File) - 
 * @param "FileBodyWithDetails" (optional.Interface of FormDataBodyPart) - 
 * @param "FileContentLength" (optional.Int64) - 
 * @param "FileDetail" (optional.Interface of FormDataContentDisposition) - 
 * @param "FlattenAssemblies" (optional.Bool) - 
 * @param "FormatName" (optional.String) - 
 * @param "IsyAxisIsUp" (optional.Bool) - 
 * @param "JoinAdjacentSurfaces" (optional.Bool) - 
 * @param "LocationElementId" (optional.String) - 
 * @param "LocationGroupId" (optional.String) - 
 * @param "LocationPosition" (optional.Int32) - 
 * @param "NotifyUser" (optional.Bool) - 
 * @param "OwnerId" (optional.String) - 
 * @param "OwnerType" (optional.String) - 
 * @param "ParentId" (optional.String) - 
 * @param "ProjectId" (optional.String) - 
 * @param "Public" (optional.Bool) - 
 * @param "SplitAssembliesIntoMultipleDocuments" (optional.Bool) - 
 * @param "StoreInDocument" (optional.Bool) - 
 * @param "Translate" (optional.Bool) - 
 * @param "Unit" (optional.String) - 
 * @param "UploadId" (optional.String) - 
 * @param "VersionString" (optional.String) - 
@return BtDocumentElementProcessingInfo
*/
func (a *BlobElementsApiService) UploadFileCreateElement(ctx _context.Context, did string, wid string, localVarOptionals *UploadFileCreateElementOpts) (BtDocumentElementProcessingInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtDocumentElementProcessingInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/blobelements/d/{did}/w/{wid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(wid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.AllowFaultyParts.IsSet() {
		localVarFormParams.Add("allowFaultyParts", parameterToString(localVarOptionals.AllowFaultyParts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreateComposite.IsSet() {
		localVarFormParams.Add("createComposite", parameterToString(localVarOptionals.CreateComposite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreateDrawingIfPossible.IsSet() {
		localVarFormParams.Add("createDrawingIfPossible", parameterToString(localVarOptionals.CreateDrawingIfPossible.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EncodedFilename.IsSet() {
		localVarFormParams.Add("encodedFilename", parameterToString(localVarOptionals.EncodedFilename.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExtractAssemblyHierarchy.IsSet() {
		localVarFormParams.Add("extractAssemblyHierarchy", parameterToString(localVarOptionals.ExtractAssemblyHierarchy.Value(), ""))
	}
	localVarFormFileName = "file"
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.File.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.File.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("file should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := _ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if localVarOptionals != nil && localVarOptionals.FileBodyWithDetails.IsSet() {
		paramJson, err := parameterToJson(localVarOptionals.FileBodyWithDetails.Value())
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("fileBodyWithDetails", paramJson)
	}
	if localVarOptionals != nil && localVarOptionals.FileContentLength.IsSet() {
		localVarFormParams.Add("fileContentLength", parameterToString(localVarOptionals.FileContentLength.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileDetail.IsSet() {
		paramJson, err := parameterToJson(localVarOptionals.FileDetail.Value())
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("fileDetail", paramJson)
	}
	if localVarOptionals != nil && localVarOptionals.FlattenAssemblies.IsSet() {
		localVarFormParams.Add("flattenAssemblies", parameterToString(localVarOptionals.FlattenAssemblies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FormatName.IsSet() {
		localVarFormParams.Add("formatName", parameterToString(localVarOptionals.FormatName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsyAxisIsUp.IsSet() {
		localVarFormParams.Add("isyAxisIsUp", parameterToString(localVarOptionals.IsyAxisIsUp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JoinAdjacentSurfaces.IsSet() {
		localVarFormParams.Add("joinAdjacentSurfaces", parameterToString(localVarOptionals.JoinAdjacentSurfaces.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationElementId.IsSet() {
		localVarFormParams.Add("locationElementId", parameterToString(localVarOptionals.LocationElementId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationGroupId.IsSet() {
		localVarFormParams.Add("locationGroupId", parameterToString(localVarOptionals.LocationGroupId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationPosition.IsSet() {
		localVarFormParams.Add("locationPosition", parameterToString(localVarOptionals.LocationPosition.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotifyUser.IsSet() {
		localVarFormParams.Add("notifyUser", parameterToString(localVarOptionals.NotifyUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerId.IsSet() {
		localVarFormParams.Add("ownerId", parameterToString(localVarOptionals.OwnerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerType.IsSet() {
		localVarFormParams.Add("ownerType", parameterToString(localVarOptionals.OwnerType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentId.IsSet() {
		localVarFormParams.Add("parentId", parameterToString(localVarOptionals.ParentId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProjectId.IsSet() {
		localVarFormParams.Add("projectId", parameterToString(localVarOptionals.ProjectId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Public.IsSet() {
		localVarFormParams.Add("public", parameterToString(localVarOptionals.Public.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SplitAssembliesIntoMultipleDocuments.IsSet() {
		localVarFormParams.Add("splitAssembliesIntoMultipleDocuments", parameterToString(localVarOptionals.SplitAssembliesIntoMultipleDocuments.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StoreInDocument.IsSet() {
		localVarFormParams.Add("storeInDocument", parameterToString(localVarOptionals.StoreInDocument.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Translate.IsSet() {
		localVarFormParams.Add("translate", parameterToString(localVarOptionals.Translate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Unit.IsSet() {
		localVarFormParams.Add("unit", parameterToString(localVarOptionals.Unit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UploadId.IsSet() {
		localVarFormParams.Add("uploadId", parameterToString(localVarOptionals.UploadId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VersionString.IsSet() {
		localVarFormParams.Add("versionString", parameterToString(localVarOptionals.VersionString.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtDocumentElementProcessingInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// UploadFileUpdateElementOpts Optional parameters for the method 'UploadFileUpdateElement'
type UploadFileUpdateElementOpts struct {
    ParentChangeId optional.String
}

/*
UploadFileUpdateElement Update Blob Element.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param eid
 * @param wid
 * @param optional nil or *UploadFileUpdateElementOpts - Optional Parameters:
 * @param "ParentChangeId" (optional.String) - 
@return BtDocumentElementProcessingInfo
*/
func (a *BlobElementsApiService) UploadFileUpdateElement(ctx _context.Context, did string, eid string, wid string, localVarOptionals *UploadFileUpdateElementOpts) (BtDocumentElementProcessingInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtDocumentElementProcessingInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/blobelements/d/{did}/w/{wid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(wid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ParentChangeId.IsSet() {
		localVarQueryParams.Add("parentChangeId", parameterToString(localVarOptionals.ParentChangeId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtDocumentElementProcessingInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
