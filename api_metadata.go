/*
 * Onshape REST API
 *
 * The Onshape REST API consumed by all clients.
 *
 * API version: 1.111
 * Contact: api-support@onshape.zendesk.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// MetadataApiService MetadataApi service
type MetadataApiService service

// GetVEOPStandardContentMetadataOpts Optional parameters for the method 'GetVEOPStandardContentMetadata'
type GetVEOPStandardContentMetadataOpts struct {
    Configuration optional.String
    LinkDocumentId optional.String
}

/*
GetVEOPStandardContentMetadata Method for GetVEOPStandardContentMetadata
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param vid
 * @param eid
 * @param otype
 * @param oid
 * @param pid
 * @param optional nil or *GetVEOPStandardContentMetadataOpts - Optional Parameters:
 * @param "Configuration" (optional.String) - 
 * @param "LinkDocumentId" (optional.String) - 
*/
func (a *MetadataApiService) GetVEOPStandardContentMetadata(ctx _context.Context, did string, vid string, eid string, otype string, oid string, pid string, localVarOptionals *GetVEOPStandardContentMetadataOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/metadata/standardcontent/d/{did}/v/{vid}/e/{eid}/{otype}/{oid}/p/{pid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"vid"+"}", _neturl.QueryEscape(parameterToString(vid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"otype"+"}", _neturl.QueryEscape(parameterToString(otype, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"oid"+"}", _neturl.QueryEscape(parameterToString(oid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"pid"+"}", _neturl.QueryEscape(parameterToString(pid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// GetWMVEMetadataOpts Optional parameters for the method 'GetWMVEMetadata'
type GetWMVEMetadataOpts struct {
    Configuration optional.String
    LinkDocumentId optional.String
    InferMetadataOwner optional.Bool
}

/*
GetWMVEMetadata Method for GetWMVEMetadata
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
 * @param optional nil or *GetWMVEMetadataOpts - Optional Parameters:
 * @param "Configuration" (optional.String) - 
 * @param "LinkDocumentId" (optional.String) - 
 * @param "InferMetadataOwner" (optional.Bool) - 
*/
func (a *MetadataApiService) GetWMVEMetadata(ctx _context.Context, did string, wvm string, wvmid string, eid string, localVarOptionals *GetWMVEMetadataOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/metadata/d/{did}/{wvm}/{wvmid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InferMetadataOwner.IsSet() {
		localVarQueryParams.Add("inferMetadataOwner", parameterToString(localVarOptionals.InferMetadataOwner.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// GetWMVEPMetadataOpts Optional parameters for the method 'GetWMVEPMetadata'
type GetWMVEPMetadataOpts struct {
    Configuration optional.String
    LinkDocumentId optional.String
    InferMetadataOwner optional.Bool
}

/*
GetWMVEPMetadata Method for GetWMVEPMetadata
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
 * @param pid
 * @param optional nil or *GetWMVEPMetadataOpts - Optional Parameters:
 * @param "Configuration" (optional.String) - 
 * @param "LinkDocumentId" (optional.String) - 
 * @param "InferMetadataOwner" (optional.Bool) - 
*/
func (a *MetadataApiService) GetWMVEPMetadata(ctx _context.Context, did string, wvm string, wvmid string, eid string, pid string, localVarOptionals *GetWMVEPMetadataOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/metadata/d/{did}/{wvm}/{wvmid}/e/{eid}/p/{pid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"pid"+"}", _neturl.QueryEscape(parameterToString(pid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InferMetadataOwner.IsSet() {
		localVarQueryParams.Add("inferMetadataOwner", parameterToString(localVarOptionals.InferMetadataOwner.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// GetWMVEPsMetadataOpts Optional parameters for the method 'GetWMVEPsMetadata'
type GetWMVEPsMetadataOpts struct {
    Configuration optional.String
    LinkDocumentId optional.String
    InferMetadataOwner optional.Bool
}

/*
GetWMVEPsMetadata Method for GetWMVEPsMetadata
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
 * @param optional nil or *GetWMVEPsMetadataOpts - Optional Parameters:
 * @param "Configuration" (optional.String) - 
 * @param "LinkDocumentId" (optional.String) - 
 * @param "InferMetadataOwner" (optional.Bool) - 
*/
func (a *MetadataApiService) GetWMVEPsMetadata(ctx _context.Context, did string, wvm string, wvmid string, eid string, localVarOptionals *GetWMVEPsMetadataOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/metadata/d/{did}/{wvm}/{wvmid}/e/{eid}/p"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InferMetadataOwner.IsSet() {
		localVarQueryParams.Add("inferMetadataOwner", parameterToString(localVarOptionals.InferMetadataOwner.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// GetWMVEsMetadataOpts Optional parameters for the method 'GetWMVEsMetadata'
type GetWMVEsMetadataOpts struct {
    LinkDocumentId optional.String
    InferMetadataOwner optional.Bool
}

/*
GetWMVEsMetadata Method for GetWMVEsMetadata
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param optional nil or *GetWMVEsMetadataOpts - Optional Parameters:
 * @param "LinkDocumentId" (optional.String) - 
 * @param "InferMetadataOwner" (optional.Bool) - 
*/
func (a *MetadataApiService) GetWMVEsMetadata(ctx _context.Context, did string, wvm string, wvmid string, localVarOptionals *GetWMVEsMetadataOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/metadata/d/{did}/{wvm}/{wvmid}/e"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InferMetadataOwner.IsSet() {
		localVarQueryParams.Add("inferMetadataOwner", parameterToString(localVarOptionals.InferMetadataOwner.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// GetWVMetadataOpts Optional parameters for the method 'GetWVMetadata'
type GetWVMetadataOpts struct {
    LinkDocumentId optional.String
    InferMetadataOwner optional.Bool
}

/*
GetWVMetadata Method for GetWVMetadata
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wv
 * @param wvid
 * @param optional nil or *GetWVMetadataOpts - Optional Parameters:
 * @param "LinkDocumentId" (optional.String) - 
 * @param "InferMetadataOwner" (optional.Bool) - 
*/
func (a *MetadataApiService) GetWVMetadata(ctx _context.Context, did string, wv string, wvid string, localVarOptionals *GetWVMetadataOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/metadata/d/{did}/{wv}/{wvid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", _neturl.QueryEscape(parameterToString(wv, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", _neturl.QueryEscape(parameterToString(wvid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InferMetadataOwner.IsSet() {
		localVarQueryParams.Add("inferMetadataOwner", parameterToString(localVarOptionals.InferMetadataOwner.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// UpdateVEOPStandardContentPartMetadataOpts Optional parameters for the method 'UpdateVEOPStandardContentPartMetadata'
type UpdateVEOPStandardContentPartMetadataOpts struct {
    LinkDocumentId optional.String
}

/*
UpdateVEOPStandardContentPartMetadata Method for UpdateVEOPStandardContentPartMetadata
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param vid
 * @param eid
 * @param otype
 * @param oid
 * @param pid
 * @param body
 * @param optional nil or *UpdateVEOPStandardContentPartMetadataOpts - Optional Parameters:
 * @param "LinkDocumentId" (optional.String) - 
*/
func (a *MetadataApiService) UpdateVEOPStandardContentPartMetadata(ctx _context.Context, did string, vid string, eid string, otype string, oid string, pid string, body string, localVarOptionals *UpdateVEOPStandardContentPartMetadataOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/metadata/standardcontent/d/{did}/v/{vid}/e/{eid}/{otype}/{oid}/p/{pid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"vid"+"}", _neturl.QueryEscape(parameterToString(vid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"otype"+"}", _neturl.QueryEscape(parameterToString(otype, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"oid"+"}", _neturl.QueryEscape(parameterToString(oid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"pid"+"}", _neturl.QueryEscape(parameterToString(pid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// UpdateWVEMetadataOpts Optional parameters for the method 'UpdateWVEMetadata'
type UpdateWVEMetadataOpts struct {
    Configuration optional.String
}

/*
UpdateWVEMetadata Method for UpdateWVEMetadata
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
 * @param body
 * @param optional nil or *UpdateWVEMetadataOpts - Optional Parameters:
 * @param "Configuration" (optional.String) - 
*/
func (a *MetadataApiService) UpdateWVEMetadata(ctx _context.Context, did string, wvm string, wvmid string, eid string, body string, localVarOptionals *UpdateWVEMetadataOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/metadata/d/{did}/{wvm}/{wvmid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// UpdateWVEPMetadataOpts Optional parameters for the method 'UpdateWVEPMetadata'
type UpdateWVEPMetadataOpts struct {
    Configuration optional.String
}

/*
UpdateWVEPMetadata Method for UpdateWVEPMetadata
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
 * @param pid
 * @param subResource
 * @param body
 * @param optional nil or *UpdateWVEPMetadataOpts - Optional Parameters:
 * @param "Configuration" (optional.String) - 
*/
func (a *MetadataApiService) UpdateWVEPMetadata(ctx _context.Context, did string, wvm string, wvmid string, eid string, pid string, subResource string, body string, localVarOptionals *UpdateWVEPMetadataOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/metadata/d/{did}/{wvm}/{wvmid}/e/{eid}/p/{pid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"pid"+"}", _neturl.QueryEscape(parameterToString(pid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"subResource"+"}", _neturl.QueryEscape(parameterToString(subResource, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
UpdateWVMetadata Method for UpdateWVMetadata
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wv
 * @param wvid
 * @param body
*/
func (a *MetadataApiService) UpdateWVMetadata(ctx _context.Context, did string, wv string, wvid string, body string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/metadata/d/{did}/{wv}/{wvid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", _neturl.QueryEscape(parameterToString(wv, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", _neturl.QueryEscape(parameterToString(wvid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
