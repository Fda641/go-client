/*
 * Onshape REST API
 *
 * The Onshape REST API consumed by all clients.
 *
 * API version: 1.111
 * Contact: api-support@onshape.zendesk.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// DefaultApiService DefaultApi service
type DefaultApiService service

/*
CreateWorkflowableTestObject Method for CreateWorkflowableTestObject
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param wfid
@return BtWorkflowableTestObjectInfo
*/
func (a *DefaultApiService) CreateWorkflowableTestObject(ctx _context.Context, wfid string) (BtWorkflowableTestObjectInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtWorkflowableTestObjectInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/workflowabletestobject/testobject/{wfid}"
	localVarPath = strings.Replace(localVarPath, "{"+"wfid"+"}", _neturl.QueryEscape(parameterToString(wfid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtWorkflowableTestObjectInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
DeleteApplicationThumbnails Method for DeleteApplicationThumbnails
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wv
 * @param wvid
 * @param eid
*/
func (a *DefaultApiService) DeleteApplicationThumbnails(ctx _context.Context, did string, wv string, wvid string, eid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/thumbnails/d/{did}/{wv}/{wvid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", _neturl.QueryEscape(parameterToString(wv, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", _neturl.QueryEscape(parameterToString(wvid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// DeleteAssociativeDataOpts Optional parameters for the method 'DeleteAssociativeData'
type DeleteAssociativeDataOpts struct {
    TransactionId optional.String
    ParentChangeId optional.String
    AssociativeDataId optional.Interface
    ElementId optional.String
    ViewId optional.String
    MicroversionId optional.String
    DocumentMicroversion optional.String
    DeterministicId optional.String
    FeatureId optional.String
    EntityId optional.String
    OccurrenceId optional.String
}

/*
DeleteAssociativeData Method for DeleteAssociativeData
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param eid
 * @param wvm
 * @param wvmid
 * @param optional nil or *DeleteAssociativeDataOpts - Optional Parameters:
 * @param "TransactionId" (optional.String) - 
 * @param "ParentChangeId" (optional.String) - 
 * @param "AssociativeDataId" (optional.Interface of []string) - 
 * @param "ElementId" (optional.String) - 
 * @param "ViewId" (optional.String) - 
 * @param "MicroversionId" (optional.String) - 
 * @param "DocumentMicroversion" (optional.String) - 
 * @param "DeterministicId" (optional.String) - 
 * @param "FeatureId" (optional.String) - 
 * @param "EntityId" (optional.String) - 
 * @param "OccurrenceId" (optional.String) - 
@return BtAppElementBasicInfo
*/
func (a *DefaultApiService) DeleteAssociativeData(ctx _context.Context, did string, eid string, wvm string, wvmid string, localVarOptionals *DeleteAssociativeDataOpts) (BtAppElementBasicInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtAppElementBasicInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/associativedata"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarQueryParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentChangeId.IsSet() {
		localVarQueryParams.Add("parentChangeId", parameterToString(localVarOptionals.ParentChangeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssociativeDataId.IsSet() {
		t:=localVarOptionals.AssociativeDataId.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("associativeDataId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("associativeDataId", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ElementId.IsSet() {
		localVarQueryParams.Add("elementId", parameterToString(localVarOptionals.ElementId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ViewId.IsSet() {
		localVarQueryParams.Add("viewId", parameterToString(localVarOptionals.ViewId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MicroversionId.IsSet() {
		localVarQueryParams.Add("microversionId", parameterToString(localVarOptionals.MicroversionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentMicroversion.IsSet() {
		localVarQueryParams.Add("documentMicroversion", parameterToString(localVarOptionals.DocumentMicroversion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeterministicId.IsSet() {
		localVarQueryParams.Add("deterministicId", parameterToString(localVarOptionals.DeterministicId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FeatureId.IsSet() {
		localVarQueryParams.Add("featureId", parameterToString(localVarOptionals.FeatureId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EntityId.IsSet() {
		localVarQueryParams.Add("entityId", parameterToString(localVarOptionals.EntityId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OccurrenceId.IsSet() {
		localVarQueryParams.Add("occurrenceId", parameterToString(localVarOptionals.OccurrenceId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtAppElementBasicInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetAssociativeDataOpts Optional parameters for the method 'GetAssociativeData'
type GetAssociativeDataOpts struct {
    TransactionId optional.String
    ChangeId optional.String
    AssociativeDataId optional.Interface
    ElementId optional.String
    ViewId optional.String
    MicroversionId optional.String
    DocumentMicroversion optional.String
    DeterministicId optional.String
    FeatureId optional.String
    EntityId optional.String
    OccurrenceId optional.String
    ReturnIdTags optional.Bool
}

/*
GetAssociativeData Method for GetAssociativeData
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
 * @param optional nil or *GetAssociativeDataOpts - Optional Parameters:
 * @param "TransactionId" (optional.String) - 
 * @param "ChangeId" (optional.String) - 
 * @param "AssociativeDataId" (optional.Interface of []string) - 
 * @param "ElementId" (optional.String) - 
 * @param "ViewId" (optional.String) - 
 * @param "MicroversionId" (optional.String) - 
 * @param "DocumentMicroversion" (optional.String) - 
 * @param "DeterministicId" (optional.String) - 
 * @param "FeatureId" (optional.String) - 
 * @param "EntityId" (optional.String) - 
 * @param "OccurrenceId" (optional.String) - 
 * @param "ReturnIdTags" (optional.Bool) - 
@return BtAppAssociativeDataInfoArray
*/
func (a *DefaultApiService) GetAssociativeData(ctx _context.Context, did string, wvm string, wvmid string, eid string, localVarOptionals *GetAssociativeDataOpts) (BtAppAssociativeDataInfoArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtAppAssociativeDataInfoArray
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/associativedata"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.TransactionId.IsSet() {
		localVarQueryParams.Add("transactionId", parameterToString(localVarOptionals.TransactionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChangeId.IsSet() {
		localVarQueryParams.Add("changeId", parameterToString(localVarOptionals.ChangeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssociativeDataId.IsSet() {
		t:=localVarOptionals.AssociativeDataId.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("associativeDataId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("associativeDataId", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ElementId.IsSet() {
		localVarQueryParams.Add("elementId", parameterToString(localVarOptionals.ElementId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ViewId.IsSet() {
		localVarQueryParams.Add("viewId", parameterToString(localVarOptionals.ViewId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MicroversionId.IsSet() {
		localVarQueryParams.Add("microversionId", parameterToString(localVarOptionals.MicroversionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentMicroversion.IsSet() {
		localVarQueryParams.Add("documentMicroversion", parameterToString(localVarOptionals.DocumentMicroversion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeterministicId.IsSet() {
		localVarQueryParams.Add("deterministicId", parameterToString(localVarOptionals.DeterministicId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FeatureId.IsSet() {
		localVarQueryParams.Add("featureId", parameterToString(localVarOptionals.FeatureId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EntityId.IsSet() {
		localVarQueryParams.Add("entityId", parameterToString(localVarOptionals.EntityId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OccurrenceId.IsSet() {
		localVarQueryParams.Add("occurrenceId", parameterToString(localVarOptionals.OccurrenceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnIdTags.IsSet() {
		localVarQueryParams.Add("returnIdTags", parameterToString(localVarOptionals.ReturnIdTags.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtAppAssociativeDataInfoArray
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetConfiguredElementThumbnailWithSizeOpts Optional parameters for the method 'GetConfiguredElementThumbnailWithSize'
type GetConfiguredElementThumbnailWithSizeOpts struct {
    T optional.String
    RejectEmpty optional.Bool
}

/*
GetConfiguredElementThumbnailWithSize Method for GetConfiguredElementThumbnailWithSize
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wid
 * @param eid
 * @param cid
 * @param sz
 * @param optional nil or *GetConfiguredElementThumbnailWithSizeOpts - Optional Parameters:
 * @param "T" (optional.String) - 
 * @param "RejectEmpty" (optional.Bool) - 
*/
func (a *DefaultApiService) GetConfiguredElementThumbnailWithSize(ctx _context.Context, did string, wid string, eid string, cid string, sz string, localVarOptionals *GetConfiguredElementThumbnailWithSizeOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/thumbnails/d/{did}/w/{wid}/e/{eid}/c/{cid}/s/{sz}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(wid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"cid"+"}", _neturl.QueryEscape(parameterToString(cid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"sz"+"}", _neturl.QueryEscape(parameterToString(sz, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.T.IsSet() {
		localVarQueryParams.Add("t", parameterToString(localVarOptionals.T.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RejectEmpty.IsSet() {
		localVarQueryParams.Add("rejectEmpty", parameterToString(localVarOptionals.RejectEmpty.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+octet-stream;charset=UTF-8;qs=0.1", "image/_*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
GetDocumentThumbnail Method for GetDocumentThumbnail
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wid
@return BtThumbnailInfo
*/
func (a *DefaultApiService) GetDocumentThumbnail(ctx _context.Context, did string, wid string) (BtThumbnailInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtThumbnailInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/thumbnails/d/{did}/w/{wid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(wid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtThumbnailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetDocumentThumbnailWithSizeOpts Optional parameters for the method 'GetDocumentThumbnailWithSize'
type GetDocumentThumbnailWithSizeOpts struct {
    T optional.String
}

/*
GetDocumentThumbnailWithSize Method for GetDocumentThumbnailWithSize
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wid
 * @param sz
 * @param optional nil or *GetDocumentThumbnailWithSizeOpts - Optional Parameters:
 * @param "T" (optional.String) - 
*/
func (a *DefaultApiService) GetDocumentThumbnailWithSize(ctx _context.Context, did string, wid string, sz string, localVarOptionals *GetDocumentThumbnailWithSizeOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/thumbnails/d/{did}/w/{wid}/s/{sz}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(wid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"sz"+"}", _neturl.QueryEscape(parameterToString(sz, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.T.IsSet() {
		localVarQueryParams.Add("t", parameterToString(localVarOptionals.T.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+octet-stream;charset=UTF-8;qs=0.1", "image/_*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// GetElementThumbnailOpts Optional parameters for the method 'GetElementThumbnail'
type GetElementThumbnailOpts struct {
    LinkDocumentId optional.String
}

/*
GetElementThumbnail Method for GetElementThumbnail
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wv
 * @param wvid
 * @param eid
 * @param optional nil or *GetElementThumbnailOpts - Optional Parameters:
 * @param "LinkDocumentId" (optional.String) - 
@return BtThumbnailInfo
*/
func (a *DefaultApiService) GetElementThumbnail(ctx _context.Context, did string, wv string, wvid string, eid string, localVarOptionals *GetElementThumbnailOpts) (BtThumbnailInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtThumbnailInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/thumbnails/d/{did}/{wv}/{wvid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", _neturl.QueryEscape(parameterToString(wv, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", _neturl.QueryEscape(parameterToString(wvid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtThumbnailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetElementThumbnailWithApiConfigurationOpts Optional parameters for the method 'GetElementThumbnailWithApiConfiguration'
type GetElementThumbnailWithApiConfigurationOpts struct {
    T optional.String
    RejectEmpty optional.Bool
}

/*
GetElementThumbnailWithApiConfiguration Method for GetElementThumbnailWithApiConfiguration
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wid
 * @param eid
 * @param cid
 * @param sz
 * @param optional nil or *GetElementThumbnailWithApiConfigurationOpts - Optional Parameters:
 * @param "T" (optional.String) - 
 * @param "RejectEmpty" (optional.Bool) - 
*/
func (a *DefaultApiService) GetElementThumbnailWithApiConfiguration(ctx _context.Context, did string, wid string, eid string, cid string, sz string, localVarOptionals *GetElementThumbnailWithApiConfigurationOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/thumbnails/d/{did}/w/{wid}/e/{eid}/ac/{cid}/s/{sz}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(wid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"cid"+"}", _neturl.QueryEscape(parameterToString(cid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"sz"+"}", _neturl.QueryEscape(parameterToString(sz, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.T.IsSet() {
		localVarQueryParams.Add("t", parameterToString(localVarOptionals.T.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RejectEmpty.IsSet() {
		localVarQueryParams.Add("rejectEmpty", parameterToString(localVarOptionals.RejectEmpty.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+octet-stream;charset=UTF-8;qs=0.1", "image/_*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// GetElementThumbnailWithSizeOpts Optional parameters for the method 'GetElementThumbnailWithSize'
type GetElementThumbnailWithSizeOpts struct {
    T optional.String
    RejectEmpty optional.Bool
}

/*
GetElementThumbnailWithSize Method for GetElementThumbnailWithSize
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wid
 * @param eid
 * @param sz
 * @param optional nil or *GetElementThumbnailWithSizeOpts - Optional Parameters:
 * @param "T" (optional.String) - 
 * @param "RejectEmpty" (optional.Bool) - 
*/
func (a *DefaultApiService) GetElementThumbnailWithSize(ctx _context.Context, did string, wid string, eid string, sz string, localVarOptionals *GetElementThumbnailWithSizeOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/thumbnails/d/{did}/w/{wid}/e/{eid}/s/{sz}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(wid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"sz"+"}", _neturl.QueryEscape(parameterToString(sz, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.T.IsSet() {
		localVarQueryParams.Add("t", parameterToString(localVarOptionals.T.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RejectEmpty.IsSet() {
		localVarQueryParams.Add("rejectEmpty", parameterToString(localVarOptionals.RejectEmpty.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+octet-stream;charset=UTF-8;qs=0.1", "image/_*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// GetLatestInDocumentOpts Optional parameters for the method 'GetLatestInDocument'
type GetLatestInDocumentOpts struct {
    BetaCapabilityIds optional.Interface
    IncludeParts optional.Bool
    IncludeSurfaces optional.Bool
    IncludeWires optional.Bool
    IncludeSketches optional.Bool
    IncludeReferenceFeatures optional.Bool
    IncludeAssemblies optional.Bool
    IncludeFeatures optional.Bool
    IncludeFeatureStudios optional.Bool
    IncludePartStudios optional.Bool
    IncludeBlobs optional.Bool
    IncludeMeshes optional.Bool
    IncludeFlattenedBodies optional.Bool
    AllowedBlobMimeTypes optional.String
    MaxFeatureScriptVersion optional.Int32
    IncludeApplications optional.Bool
    AllowedApplicationMimeTypes optional.String
    IncludeCompositeParts optional.Bool
    IncludeFSTables optional.Bool
}

/*
GetLatestInDocument insertables for a document
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param optional nil or *GetLatestInDocumentOpts - Optional Parameters:
 * @param "BetaCapabilityIds" (optional.Interface of []string) - 
 * @param "IncludeParts" (optional.Bool) - 
 * @param "IncludeSurfaces" (optional.Bool) - 
 * @param "IncludeWires" (optional.Bool) - 
 * @param "IncludeSketches" (optional.Bool) - 
 * @param "IncludeReferenceFeatures" (optional.Bool) - 
 * @param "IncludeAssemblies" (optional.Bool) - 
 * @param "IncludeFeatures" (optional.Bool) - 
 * @param "IncludeFeatureStudios" (optional.Bool) - 
 * @param "IncludePartStudios" (optional.Bool) - 
 * @param "IncludeBlobs" (optional.Bool) - 
 * @param "IncludeMeshes" (optional.Bool) - 
 * @param "IncludeFlattenedBodies" (optional.Bool) - 
 * @param "AllowedBlobMimeTypes" (optional.String) - 
 * @param "MaxFeatureScriptVersion" (optional.Int32) - 
 * @param "IncludeApplications" (optional.Bool) - 
 * @param "AllowedApplicationMimeTypes" (optional.String) - 
 * @param "IncludeCompositeParts" (optional.Bool) - 
 * @param "IncludeFSTables" (optional.Bool) - 
@return BtListResponseBtInsertableInfo
*/
func (a *DefaultApiService) GetLatestInDocument(ctx _context.Context, did string, localVarOptionals *GetLatestInDocumentOpts) (BtListResponseBtInsertableInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtListResponseBtInsertableInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/insertables/d/{did}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.BetaCapabilityIds.IsSet() {
		t:=localVarOptionals.BetaCapabilityIds.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("betaCapabilityIds", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("betaCapabilityIds", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.IncludeParts.IsSet() {
		localVarQueryParams.Add("includeParts", parameterToString(localVarOptionals.IncludeParts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeSurfaces.IsSet() {
		localVarQueryParams.Add("includeSurfaces", parameterToString(localVarOptionals.IncludeSurfaces.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeWires.IsSet() {
		localVarQueryParams.Add("includeWires", parameterToString(localVarOptionals.IncludeWires.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeSketches.IsSet() {
		localVarQueryParams.Add("includeSketches", parameterToString(localVarOptionals.IncludeSketches.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeReferenceFeatures.IsSet() {
		localVarQueryParams.Add("includeReferenceFeatures", parameterToString(localVarOptionals.IncludeReferenceFeatures.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeAssemblies.IsSet() {
		localVarQueryParams.Add("includeAssemblies", parameterToString(localVarOptionals.IncludeAssemblies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFeatures.IsSet() {
		localVarQueryParams.Add("includeFeatures", parameterToString(localVarOptionals.IncludeFeatures.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFeatureStudios.IsSet() {
		localVarQueryParams.Add("includeFeatureStudios", parameterToString(localVarOptionals.IncludeFeatureStudios.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludePartStudios.IsSet() {
		localVarQueryParams.Add("includePartStudios", parameterToString(localVarOptionals.IncludePartStudios.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeBlobs.IsSet() {
		localVarQueryParams.Add("includeBlobs", parameterToString(localVarOptionals.IncludeBlobs.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeMeshes.IsSet() {
		localVarQueryParams.Add("includeMeshes", parameterToString(localVarOptionals.IncludeMeshes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFlattenedBodies.IsSet() {
		localVarQueryParams.Add("includeFlattenedBodies", parameterToString(localVarOptionals.IncludeFlattenedBodies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AllowedBlobMimeTypes.IsSet() {
		localVarQueryParams.Add("allowedBlobMimeTypes", parameterToString(localVarOptionals.AllowedBlobMimeTypes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxFeatureScriptVersion.IsSet() {
		localVarQueryParams.Add("maxFeatureScriptVersion", parameterToString(localVarOptionals.MaxFeatureScriptVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeApplications.IsSet() {
		localVarQueryParams.Add("includeApplications", parameterToString(localVarOptionals.IncludeApplications.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AllowedApplicationMimeTypes.IsSet() {
		localVarQueryParams.Add("allowedApplicationMimeTypes", parameterToString(localVarOptionals.AllowedApplicationMimeTypes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeCompositeParts.IsSet() {
		localVarQueryParams.Add("includeCompositeParts", parameterToString(localVarOptionals.IncludeCompositeParts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeFSTables.IsSet() {
		localVarQueryParams.Add("includeFSTables", parameterToString(localVarOptionals.IncludeFSTables.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtListResponseBtInsertableInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetMetadataSchemaOpts Optional parameters for the method 'GetMetadataSchema'
type GetMetadataSchemaOpts struct {
    OwnerId optional.String
    DocumentId optional.String
    OwnerType optional.Int32
}

/*
GetMetadataSchema Method for GetMetadataSchema
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param objectType
 * @param optional nil or *GetMetadataSchemaOpts - Optional Parameters:
 * @param "OwnerId" (optional.String) - 
 * @param "DocumentId" (optional.String) - 
 * @param "OwnerType" (optional.Int32) - 
@return BtMetadataSchemaInfo
*/
func (a *DefaultApiService) GetMetadataSchema(ctx _context.Context, objectType int32, localVarOptionals *GetMetadataSchemaOpts) (BtMetadataSchemaInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtMetadataSchemaInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/metadataschema"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.OwnerId.IsSet() {
		localVarQueryParams.Add("ownerId", parameterToString(localVarOptionals.OwnerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentId.IsSet() {
		localVarQueryParams.Add("documentId", parameterToString(localVarOptionals.DocumentId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerType.IsSet() {
		localVarQueryParams.Add("ownerType", parameterToString(localVarOptionals.OwnerType.Value(), ""))
	}
	localVarQueryParams.Add("objectType", parameterToString(objectType, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtMetadataSchemaInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetPropertiesOpts Optional parameters for the method 'GetProperties'
type GetPropertiesOpts struct {
    SchemaId optional.String
    OwnerId optional.String
    DocumentId optional.String
    OwnerType optional.Int32
    ObjectType optional.Int32
    Strict optional.Bool
    ActiveOnly optional.Bool
    Offset optional.Int32
    Limit optional.Int32
}

/*
GetProperties Method for GetProperties
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *GetPropertiesOpts - Optional Parameters:
 * @param "SchemaId" (optional.String) - 
 * @param "OwnerId" (optional.String) - 
 * @param "DocumentId" (optional.String) - 
 * @param "OwnerType" (optional.Int32) - 
 * @param "ObjectType" (optional.Int32) - 
 * @param "Strict" (optional.Bool) - 
 * @param "ActiveOnly" (optional.Bool) - 
 * @param "Offset" (optional.Int32) - 
 * @param "Limit" (optional.Int32) - 
@return BtListResponseBtMetadataPropertySummaryInfo
*/
func (a *DefaultApiService) GetProperties(ctx _context.Context, localVarOptionals *GetPropertiesOpts) (BtListResponseBtMetadataPropertySummaryInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtListResponseBtMetadataPropertySummaryInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/metadataschema/properties"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.SchemaId.IsSet() {
		localVarQueryParams.Add("schemaId", parameterToString(localVarOptionals.SchemaId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerId.IsSet() {
		localVarQueryParams.Add("ownerId", parameterToString(localVarOptionals.OwnerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DocumentId.IsSet() {
		localVarQueryParams.Add("documentId", parameterToString(localVarOptionals.DocumentId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerType.IsSet() {
		localVarQueryParams.Add("ownerType", parameterToString(localVarOptionals.OwnerType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectType.IsSet() {
		localVarQueryParams.Add("objectType", parameterToString(localVarOptionals.ObjectType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Strict.IsSet() {
		localVarQueryParams.Add("strict", parameterToString(localVarOptionals.Strict.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ActiveOnly.IsSet() {
		localVarQueryParams.Add("activeOnly", parameterToString(localVarOptionals.ActiveOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtListResponseBtMetadataPropertySummaryInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetPropertyInfoOpts Optional parameters for the method 'GetPropertyInfo'
type GetPropertyInfoOpts struct {
    DocumentId optional.String
    SchemaId optional.String
    OwnerId optional.String
    OwnerType optional.Int32
    ObjectType optional.Int32
}

/*
GetPropertyInfo Method for GetPropertyInfo
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pid
 * @param optional nil or *GetPropertyInfoOpts - Optional Parameters:
 * @param "DocumentId" (optional.String) - 
 * @param "SchemaId" (optional.String) - 
 * @param "OwnerId" (optional.String) - 
 * @param "OwnerType" (optional.Int32) - 
 * @param "ObjectType" (optional.Int32) - 
@return BtMetadataPropertyInfo
*/
func (a *DefaultApiService) GetPropertyInfo(ctx _context.Context, pid string, localVarOptionals *GetPropertyInfoOpts) (BtMetadataPropertyInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtMetadataPropertyInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/metadataschema/propertyinfo/{pid}"
	localVarPath = strings.Replace(localVarPath, "{"+"pid"+"}", _neturl.QueryEscape(parameterToString(pid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.DocumentId.IsSet() {
		localVarQueryParams.Add("documentId", parameterToString(localVarOptionals.DocumentId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SchemaId.IsSet() {
		localVarQueryParams.Add("schemaId", parameterToString(localVarOptionals.SchemaId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerId.IsSet() {
		localVarQueryParams.Add("ownerId", parameterToString(localVarOptionals.OwnerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerType.IsSet() {
		localVarQueryParams.Add("ownerType", parameterToString(localVarOptionals.OwnerType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectType.IsSet() {
		localVarQueryParams.Add("objectType", parameterToString(localVarOptionals.ObjectType.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtMetadataPropertyInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetSchemaOpts Optional parameters for the method 'GetSchema'
type GetSchemaOpts struct {
    DocumentId optional.String
}

/*
GetSchema Method for GetSchema
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param sid
 * @param optional nil or *GetSchemaOpts - Optional Parameters:
 * @param "DocumentId" (optional.String) - 
@return BtMetadataSchemaInfo
*/
func (a *DefaultApiService) GetSchema(ctx _context.Context, sid string, localVarOptionals *GetSchemaOpts) (BtMetadataSchemaInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtMetadataSchemaInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/metadataschema/{sid}"
	localVarPath = strings.Replace(localVarPath, "{"+"sid"+"}", _neturl.QueryEscape(parameterToString(sid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.DocumentId.IsSet() {
		localVarQueryParams.Add("documentId", parameterToString(localVarOptionals.DocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtMetadataSchemaInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetSketchBoundingBoxesOpts Optional parameters for the method 'GetSketchBoundingBoxes'
type GetSketchBoundingBoxesOpts struct {
    Configuration optional.String
    LinkDocumentId optional.String
}

/*
GetSketchBoundingBoxes Method for GetSketchBoundingBoxes
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
 * @param sid
 * @param optional nil or *GetSketchBoundingBoxesOpts - Optional Parameters:
 * @param "Configuration" (optional.String) - 
 * @param "LinkDocumentId" (optional.String) - 
@return BtBoundingBoxInfo
*/
func (a *DefaultApiService) GetSketchBoundingBoxes(ctx _context.Context, did string, wvm string, wvmid string, eid string, sid string, localVarOptionals *GetSketchBoundingBoxesOpts) (BtBoundingBoxInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtBoundingBoxInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/sketches/{sid}/boundingboxes"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"sid"+"}", _neturl.QueryEscape(parameterToString(sid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtBoundingBoxInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetSketchInfoOpts Optional parameters for the method 'GetSketchInfo'
type GetSketchInfoOpts struct {
    Configuration optional.String
    SketchId optional.Interface
    Output3D optional.Bool
    CurvePoints optional.Bool
    IncludeGeometry optional.Bool
    LinkDocumentId optional.String
}

/*
GetSketchInfo Method for GetSketchInfo
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
 * @param optional nil or *GetSketchInfoOpts - Optional Parameters:
 * @param "Configuration" (optional.String) - 
 * @param "SketchId" (optional.Interface of []string) - 
 * @param "Output3D" (optional.Bool) - 
 * @param "CurvePoints" (optional.Bool) - 
 * @param "IncludeGeometry" (optional.Bool) - 
 * @param "LinkDocumentId" (optional.String) - 
*/
func (a *DefaultApiService) GetSketchInfo(ctx _context.Context, did string, wvm string, wvmid string, eid string, localVarOptionals *GetSketchInfoOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/sketches"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SketchId.IsSet() {
		t:=localVarOptionals.SketchId.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sketchId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sketchId", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Output3D.IsSet() {
		localVarQueryParams.Add("output3D", parameterToString(localVarOptionals.Output3D.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CurvePoints.IsSet() {
		localVarQueryParams.Add("curvePoints", parameterToString(localVarOptionals.CurvePoints.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeGeometry.IsSet() {
		localVarQueryParams.Add("includeGeometry", parameterToString(localVarOptionals.IncludeGeometry.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// GetTessellatedEntitiesOpts Optional parameters for the method 'GetTessellatedEntities'
type GetTessellatedEntitiesOpts struct {
    Configuration optional.String
    EntityId optional.Interface
    AngleTolerance optional.Float64
    ChordTolerance optional.Float64
    LinkDocumentId optional.String
}

/*
GetTessellatedEntities Method for GetTessellatedEntities
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
 * @param sid
 * @param optional nil or *GetTessellatedEntitiesOpts - Optional Parameters:
 * @param "Configuration" (optional.String) - 
 * @param "EntityId" (optional.Interface of []string) - 
 * @param "AngleTolerance" (optional.Float64) - 
 * @param "ChordTolerance" (optional.Float64) - 
 * @param "LinkDocumentId" (optional.String) - 
*/
func (a *DefaultApiService) GetTessellatedEntities(ctx _context.Context, did string, wvm string, wvmid string, eid string, sid string, localVarOptionals *GetTessellatedEntitiesOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/sketches/{sid}/tessellatedentities"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"sid"+"}", _neturl.QueryEscape(parameterToString(sid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EntityId.IsSet() {
		t:=localVarOptionals.EntityId.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("entityId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("entityId", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.AngleTolerance.IsSet() {
		localVarQueryParams.Add("angleTolerance", parameterToString(localVarOptionals.AngleTolerance.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChordTolerance.IsSet() {
		localVarQueryParams.Add("chordTolerance", parameterToString(localVarOptionals.ChordTolerance.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
GetThumbnailForDocument Method for GetThumbnailForDocument
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
@return BtThumbnailInfo
*/
func (a *DefaultApiService) GetThumbnailForDocument(ctx _context.Context, did string) (BtThumbnailInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtThumbnailInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/thumbnails/d/{did}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtThumbnailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetThumbnailForDocumentAndVersionOpts Optional parameters for the method 'GetThumbnailForDocumentAndVersion'
type GetThumbnailForDocumentAndVersionOpts struct {
    LinkDocumentId optional.String
}

/*
GetThumbnailForDocumentAndVersion Method for GetThumbnailForDocumentAndVersion
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param vid
 * @param optional nil or *GetThumbnailForDocumentAndVersionOpts - Optional Parameters:
 * @param "LinkDocumentId" (optional.String) - 
*/
func (a *DefaultApiService) GetThumbnailForDocumentAndVersion(ctx _context.Context, did string, vid string, localVarOptionals *GetThumbnailForDocumentAndVersionOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/thumbnails/d/{did}/v/{vid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"vid"+"}", _neturl.QueryEscape(parameterToString(vid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
GetThumbnailForDocumentAndVersionOld Method for GetThumbnailForDocumentAndVersionOld
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param vid
*/
func (a *DefaultApiService) GetThumbnailForDocumentAndVersionOld(ctx _context.Context, did string, vid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/thumbnails/document/{did}/version/{vid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"vid"+"}", _neturl.QueryEscape(parameterToString(vid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
GetThumbnailForDocumentOld Method for GetThumbnailForDocumentOld
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
@return BtThumbnailInfo
*/
func (a *DefaultApiService) GetThumbnailForDocumentOld(ctx _context.Context, did string) (BtThumbnailInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtThumbnailInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/thumbnails/document/{did}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtThumbnailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetWorkflowableTestObject Method for GetWorkflowableTestObject
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param oid
@return BtWorkflowableTestObjectInfo
*/
func (a *DefaultApiService) GetWorkflowableTestObject(ctx _context.Context, oid string) (BtWorkflowableTestObjectInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtWorkflowableTestObjectInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/workflowabletestobject/{oid}"
	localVarPath = strings.Replace(localVarPath, "{"+"oid"+"}", _neturl.QueryEscape(parameterToString(oid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtWorkflowableTestObjectInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
PostAssociativeData Method for PostAssociativeData
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param eid
 * @param wvm
 * @param wvmid
 * @param body
@return BtAppAssociativeDataInfoArray
*/
func (a *DefaultApiService) PostAssociativeData(ctx _context.Context, did string, eid string, wvm string, wvmid string, body string) (BtAppAssociativeDataInfoArray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtAppAssociativeDataInfoArray
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/associativedata"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtAppAssociativeDataInfoArray
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SetApplicationElementThumbnailOpts Optional parameters for the method 'SetApplicationElementThumbnail'
type SetApplicationElementThumbnailOpts struct {
    Overwrite optional.Bool
}

/*
SetApplicationElementThumbnail Method for SetApplicationElementThumbnail
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wv
 * @param wvid
 * @param eid
 * @param btApplicationElementThumbnailParamsArray
 * @param optional nil or *SetApplicationElementThumbnailOpts - Optional Parameters:
 * @param "Overwrite" (optional.Bool) - 
*/
func (a *DefaultApiService) SetApplicationElementThumbnail(ctx _context.Context, did string, wv string, wvid string, eid string, btApplicationElementThumbnailParamsArray BtApplicationElementThumbnailParamsArray, localVarOptionals *SetApplicationElementThumbnailOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/thumbnails/d/{did}/{wv}/{wvid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", _neturl.QueryEscape(parameterToString(wv, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", _neturl.QueryEscape(parameterToString(wvid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Overwrite.IsSet() {
		localVarQueryParams.Add("overwrite", parameterToString(localVarOptionals.Overwrite.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &btApplicationElementThumbnailParamsArray
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
TransitionWorkflowableTestObject Method for TransitionWorkflowableTestObject
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param oid
 * @param transition
@return BtWorkflowableTestObjectInfo
*/
func (a *DefaultApiService) TransitionWorkflowableTestObject(ctx _context.Context, oid string, transition string) (BtWorkflowableTestObjectInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtWorkflowableTestObjectInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/workflowabletestobject/{oid}/{transition}"
	localVarPath = strings.Replace(localVarPath, "{"+"oid"+"}", _neturl.QueryEscape(parameterToString(oid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"transition"+"}", _neturl.QueryEscape(parameterToString(transition, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtWorkflowableTestObjectInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
UpdateWorkflowableTestObject Method for UpdateWorkflowableTestObject
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param oid
 * @param btUpdateWorkflowableTestObjectParams
@return BtWorkflowableTestObjectInfo
*/
func (a *DefaultApiService) UpdateWorkflowableTestObject(ctx _context.Context, oid string, btUpdateWorkflowableTestObjectParams BtUpdateWorkflowableTestObjectParams) (BtWorkflowableTestObjectInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtWorkflowableTestObjectInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/workflowabletestobject/{oid}"
	localVarPath = strings.Replace(localVarPath, "{"+"oid"+"}", _neturl.QueryEscape(parameterToString(oid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/json;charset=UTF-8; qs=0.09"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &btUpdateWorkflowableTestObjectParams
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtWorkflowableTestObjectInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
