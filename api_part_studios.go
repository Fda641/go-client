/*
 * Onshape REST API
 *
 * The Onshape REST API consumed by all clients.
 *
 * API version: 1.111
 * Contact: api-support@onshape.zendesk.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// PartStudiosApiService PartStudiosApi service
type PartStudiosApiService service

// AddPartStudioFeatureOpts Optional parameters for the method 'AddPartStudioFeature'
type AddPartStudioFeatureOpts struct {
    BtFeatureDefinitionCall1406 optional.Interface
}

/*
AddPartStudioFeature Add Feature
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
 * @param optional nil or *AddPartStudioFeatureOpts - Optional Parameters:
 * @param "BtFeatureDefinitionCall1406" (optional.Interface of BtFeatureDefinitionCall1406) -  feature The serialized feature definition
@return BtFeatureDefinitionResponse1617
*/
func (a *PartStudiosApiService) AddPartStudioFeature(ctx _context.Context, did string, wvm string, wvmid string, eid string, localVarOptionals *AddPartStudioFeatureOpts) (BtFeatureDefinitionResponse1617, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtFeatureDefinitionResponse1617
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.BtFeatureDefinitionCall1406.IsSet() {
		localVarOptionalBtFeatureDefinitionCall1406, localVarOptionalBtFeatureDefinitionCall1406ok := localVarOptionals.BtFeatureDefinitionCall1406.Value().(BtFeatureDefinitionCall1406)
		if !localVarOptionalBtFeatureDefinitionCall1406ok {
			return localVarReturnValue, nil, reportError("btFeatureDefinitionCall1406 should be BtFeatureDefinitionCall1406")
		}
		localVarPostBody = &localVarOptionalBtFeatureDefinitionCall1406
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtFeatureDefinitionResponse1617
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ComparePartStudiosOpts Optional parameters for the method 'ComparePartStudios'
type ComparePartStudiosOpts struct {
    WorkspaceId optional.String
    VersionId optional.String
    MicroversionId optional.String
    SourceConfiguration optional.String
    TargetConfiguration optional.String
    LinkDocumentId optional.String
}

/*
ComparePartStudios Compare Part Studios
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did Document ID.
 * @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 * @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 * @param eid Element ID.
 * @param optional nil or *ComparePartStudiosOpts - Optional Parameters:
 * @param "WorkspaceId" (optional.String) - 
 * @param "VersionId" (optional.String) - 
 * @param "MicroversionId" (optional.String) - 
 * @param "SourceConfiguration" (optional.String) - 
 * @param "TargetConfiguration" (optional.String) - 
 * @param "LinkDocumentId" (optional.String) - 
@return BtRootDiffInfo
*/
func (a *PartStudiosApiService) ComparePartStudios(ctx _context.Context, did string, wvm string, wvmid string, eid string, localVarOptionals *ComparePartStudiosOpts) (BtRootDiffInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtRootDiffInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/compare"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.WorkspaceId.IsSet() {
		localVarQueryParams.Add("workspaceId", parameterToString(localVarOptionals.WorkspaceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VersionId.IsSet() {
		localVarQueryParams.Add("versionId", parameterToString(localVarOptionals.VersionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MicroversionId.IsSet() {
		localVarQueryParams.Add("microversionId", parameterToString(localVarOptionals.MicroversionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceConfiguration.IsSet() {
		localVarQueryParams.Add("sourceConfiguration", parameterToString(localVarOptionals.SourceConfiguration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetConfiguration.IsSet() {
		localVarQueryParams.Add("targetConfiguration", parameterToString(localVarOptionals.TargetConfiguration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtRootDiffInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
CreatePartStudio Create Part Studio
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did Document ID.
 * @param wid Workspace ID.
 * @param btModelElementParams
@return BtDocumentElementInfo
*/
func (a *PartStudiosApiService) CreatePartStudio(ctx _context.Context, did string, wid string, btModelElementParams BtModelElementParams) (BtDocumentElementInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtDocumentElementInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/w/{wid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(wid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &btModelElementParams
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtDocumentElementInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
CreatePartStudioTranslation Create Part Studio translation
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did Document ID.
 * @param wv One of w or v corresponding to whether a workspace or version was specified.
 * @param wvid Workspace (w) or Version (v) ID.
 * @param eid Element ID.
 * @param btTranslateFormatParams
@return BtTranslationRequestInfo
*/
func (a *PartStudiosApiService) CreatePartStudioTranslation(ctx _context.Context, did string, wv string, wvid string, eid string, btTranslateFormatParams BtTranslateFormatParams) (BtTranslationRequestInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtTranslationRequestInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wv}/{wvid}/e/{eid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", _neturl.QueryEscape(parameterToString(wv, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", _neturl.QueryEscape(parameterToString(wvid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &btTranslateFormatParams
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtTranslationRequestInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
DeletePartStudioFeature Delete Feature
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did Document ID.
 * @param wid Workspace ID.
 * @param eid Element ID.
 * @param fid The id of the feature being updated. This id should be URL encoded and must match the featureId found in the serialized structure
@return BtFeatureApiBase1430
*/
func (a *PartStudiosApiService) DeletePartStudioFeature(ctx _context.Context, did string, wid string, eid string, fid string) (BtFeatureApiBase1430, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtFeatureApiBase1430
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(wid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"fid"+"}", _neturl.QueryEscape(parameterToString(fid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtFeatureApiBase1430
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// EvalFeatureScriptOpts Optional parameters for the method 'EvalFeatureScript'
type EvalFeatureScriptOpts struct {
    Configuration optional.String
    BtFeatureScriptEvalCall2377 optional.Interface
}

/*
EvalFeatureScript Evaluate FeatureScript
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did Document ID.
 * @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 * @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 * @param eid Element ID.
 * @param optional nil or *EvalFeatureScriptOpts - Optional Parameters:
 * @param "Configuration" (optional.String) -  Configuration string.
 * @param "BtFeatureScriptEvalCall2377" (optional.Interface of BtFeatureScriptEvalCall2377) - 
@return BtFeatureScriptEvalResponse1859
*/
func (a *PartStudiosApiService) EvalFeatureScript(ctx _context.Context, did string, wvm string, wvmid string, eid string, localVarOptionals *EvalFeatureScriptOpts) (BtFeatureScriptEvalResponse1859, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtFeatureScriptEvalResponse1859
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/featurescript"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.BtFeatureScriptEvalCall2377.IsSet() {
		localVarOptionalBtFeatureScriptEvalCall2377, localVarOptionalBtFeatureScriptEvalCall2377ok := localVarOptionals.BtFeatureScriptEvalCall2377.Value().(BtFeatureScriptEvalCall2377)
		if !localVarOptionalBtFeatureScriptEvalCall2377ok {
			return localVarReturnValue, nil, reportError("btFeatureScriptEvalCall2377 should be BtFeatureScriptEvalCall2377")
		}
		localVarPostBody = &localVarOptionalBtFeatureScriptEvalCall2377
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtFeatureScriptEvalResponse1859
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExportPS1Opts Optional parameters for the method 'ExportPS1'
type ExportPS1Opts struct {
    PartIds optional.String
    Version optional.String
    IncludeExportIds optional.Bool
    Configuration optional.String
    LinkDocumentId optional.String
}

/*
ExportPS1 Export Part Studio to Parasolid
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did Document ID.
 * @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 * @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 * @param eid Element ID.
 * @param optional nil or *ExportPS1Opts - Optional Parameters:
 * @param "PartIds" (optional.String) -  IDs of the parts to retrieve. Repeat query param to add more than one (i.e. partId=JHK&partId=JHD). May not be combined with other ID filters
 * @param "Version" (optional.String) -  Parasolid version
 * @param "IncludeExportIds" (optional.Bool) -  Whether topolgy ids should be exported as parasolid attributes
 * @param "Configuration" (optional.String) -  Configuration string.
 * @param "LinkDocumentId" (optional.String) -  Id of document that links to the document being accessed. This may provide additional access rights to the document. Allowed only with version (v) path parameter.
*/
func (a *PartStudiosApiService) ExportPS1(ctx _context.Context, did string, wvm string, wvmid string, eid string, localVarOptionals *ExportPS1Opts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/parasolid"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.PartIds.IsSet() {
		localVarQueryParams.Add("partIds", parameterToString(localVarOptionals.PartIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Version.IsSet() {
		localVarQueryParams.Add("version", parameterToString(localVarOptionals.Version.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeExportIds.IsSet() {
		localVarQueryParams.Add("includeExportIds", parameterToString(localVarOptionals.IncludeExportIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ExportStl1Opts Optional parameters for the method 'ExportStl1'
type ExportStl1Opts struct {
    PartIds optional.String
    Mode optional.String
    Grouping optional.Bool
    Scale optional.Float64
    Units optional.String
    AngleTolerance optional.Float64
    ChordTolerance optional.Float64
    MaxFacetWidth optional.Float64
    MinFacetWidth optional.Float64
    Configuration optional.String
    LinkDocumentId optional.String
}

/*
ExportStl1 Export Part Studio to STL
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did Document ID.
 * @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 * @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 * @param eid Element ID.
 * @param optional nil or *ExportStl1Opts - Optional Parameters:
 * @param "PartIds" (optional.String) -  IDs of the parts to retrieve. Repeat query param to add more than one (i.e. partId=JHK&partId=JHD). May not be combined with other ID filters
 * @param "Mode" (optional.String) -  Type of file: text, binary
 * @param "Grouping" (optional.Bool) -  Whether parts should be exported as a group or individually in a .zip file
 * @param "Scale" (optional.Float64) -  Scale for measurements.
 * @param "Units" (optional.String) -  Name of base unit (meter, centimeter, millimeter, inch, foot, or yard)
 * @param "AngleTolerance" (optional.Float64) -  Angle tolerance (in radians). This specifies the limit on the sum of the angular deviations of a tessellation chord from the tangent vectors at two chord endpoints. The specified value must be less than PI/2. This parameter currently has a default value chosen based on the complexity of the parts being tessellated.
 * @param "ChordTolerance" (optional.Float64) -  Chord tolerance (in meters). This specifies the limit on the maximum deviation of a tessellation chord from the true surface/edge. This parameter currently has a default value chosen based on the size and complexity of the parts being tessellated.
 * @param "MaxFacetWidth" (optional.Float64) -  Max facet width. This specifies the limit on the size of any side of a tessellation facet.
 * @param "MinFacetWidth" (optional.Float64) -  Max facet width. This specifies the limit on the size of any side of a tessellation facet.
 * @param "Configuration" (optional.String) -  Configuration string.
 * @param "LinkDocumentId" (optional.String) -  Id of document that links to the document being accessed. This may provide additional access rights to the document. Allowed only with version (v) path parameter.
*/
func (a *PartStudiosApiService) ExportStl1(ctx _context.Context, did string, wvm string, wvmid string, eid string, localVarOptionals *ExportStl1Opts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/stl"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.PartIds.IsSet() {
		localVarQueryParams.Add("partIds", parameterToString(localVarOptionals.PartIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Mode.IsSet() {
		localVarQueryParams.Add("mode", parameterToString(localVarOptionals.Mode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Scale.IsSet() {
		localVarQueryParams.Add("scale", parameterToString(localVarOptionals.Scale.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Units.IsSet() {
		localVarQueryParams.Add("units", parameterToString(localVarOptionals.Units.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AngleTolerance.IsSet() {
		localVarQueryParams.Add("angleTolerance", parameterToString(localVarOptionals.AngleTolerance.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChordTolerance.IsSet() {
		localVarQueryParams.Add("chordTolerance", parameterToString(localVarOptionals.ChordTolerance.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxFacetWidth.IsSet() {
		localVarQueryParams.Add("maxFacetWidth", parameterToString(localVarOptionals.MaxFacetWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MinFacetWidth.IsSet() {
		localVarQueryParams.Add("minFacetWidth", parameterToString(localVarOptionals.MinFacetWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// GetPartStudioBodyDetailsOpts Optional parameters for the method 'GetPartStudioBodyDetails'
type GetPartStudioBodyDetailsOpts struct {
    Configuration optional.String
    LinkDocumentId optional.String
    RollbackBarIndex optional.Int32
    Body optional.String
}

/*
GetPartStudioBodyDetails Array of body information
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
 * @param optional nil or *GetPartStudioBodyDetailsOpts - Optional Parameters:
 * @param "Configuration" (optional.String) - 
 * @param "LinkDocumentId" (optional.String) - 
 * @param "RollbackBarIndex" (optional.Int32) - 
 * @param "Body" (optional.String) - 
@return BtExportModelBodiesResponse734
*/
func (a *PartStudiosApiService) GetPartStudioBodyDetails(ctx _context.Context, did string, wvm string, wvmid string, eid string, localVarOptionals *GetPartStudioBodyDetailsOpts) (BtExportModelBodiesResponse734, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtExportModelBodiesResponse734
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/bodydetails"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RollbackBarIndex.IsSet() {
		localVarQueryParams.Add("rollbackBarIndex", parameterToString(localVarOptionals.RollbackBarIndex.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		localVarPostBody = localVarOptionals.Body.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtExportModelBodiesResponse734
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetPartStudioBoundingBoxesOpts Optional parameters for the method 'GetPartStudioBoundingBoxes'
type GetPartStudioBoundingBoxesOpts struct {
    IncludeHidden optional.Bool
    IncludeWireBodies optional.Bool
    Configuration optional.String
    LinkDocumentId optional.String
}

/*
GetPartStudioBoundingBoxes Mass properties of parts or a PartStudio.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did Document ID.
 * @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 * @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 * @param eid Element ID.
 * @param optional nil or *GetPartStudioBoundingBoxesOpts - Optional Parameters:
 * @param "IncludeHidden" (optional.Bool) -  Whether or not to include bounding boxes for hidden parts.
 * @param "IncludeWireBodies" (optional.Bool) -  Whether to include wire bodies in the bounding box.
 * @param "Configuration" (optional.String) -  Configuration string.
 * @param "LinkDocumentId" (optional.String) -  Id of document that links to the document being accessed. This may provide additional access rights to the document. Allowed only with version (v) path parameter.
@return BtBoundingBoxInfo
*/
func (a *PartStudiosApiService) GetPartStudioBoundingBoxes(ctx _context.Context, did string, wvm string, wvmid string, eid string, localVarOptionals *GetPartStudioBoundingBoxesOpts) (BtBoundingBoxInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtBoundingBoxInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/boundingboxes"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeHidden.IsSet() {
		localVarQueryParams.Add("includeHidden", parameterToString(localVarOptionals.IncludeHidden.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeWireBodies.IsSet() {
		localVarQueryParams.Add("includeWireBodies", parameterToString(localVarOptionals.IncludeWireBodies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtBoundingBoxInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetPartStudioConfiguration Get Configuration
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
*/
func (a *PartStudiosApiService) GetPartStudioConfiguration(ctx _context.Context, did string, wvm string, wvmid string, eid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/configuration"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
GetPartStudioFeatureSpecs Get Feature Specs
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did Document ID.
 * @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 * @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 * @param eid Element ID.
@return BtFeatureSpecsResponse664
*/
func (a *PartStudiosApiService) GetPartStudioFeatureSpecs(ctx _context.Context, did string, wvm string, wvmid string, eid string) (BtFeatureSpecsResponse664, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtFeatureSpecsResponse664
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/featurespecs"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtFeatureSpecsResponse664
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetPartStudioFeaturesOpts Optional parameters for the method 'GetPartStudioFeatures'
type GetPartStudioFeaturesOpts struct {
    FeatureId optional.Interface
    LinkDocumentId optional.String
    NoSketchGeometry optional.Bool
}

/*
GetPartStudioFeatures Get Feature List
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did Document ID.
 * @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 * @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 * @param eid Element ID.
 * @param optional nil or *GetPartStudioFeaturesOpts - Optional Parameters:
 * @param "FeatureId" (optional.Interface of []string) -  ID of a feature; repeat query param to add more than one
 * @param "LinkDocumentId" (optional.String) -  Id of document that links to the document being accessed. This may provide additional access rights to the document. Allowed only with version (v) path parameter.
 * @param "NoSketchGeometry" (optional.Bool) -  Whether or not to output simple sketch info without geometry
@return BtFeatureListResponse2457
*/
func (a *PartStudiosApiService) GetPartStudioFeatures(ctx _context.Context, did string, wvm string, wvmid string, eid string, localVarOptionals *GetPartStudioFeaturesOpts) (BtFeatureListResponse2457, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtFeatureListResponse2457
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FeatureId.IsSet() {
		t:=localVarOptionals.FeatureId.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("featureId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("featureId", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NoSketchGeometry.IsSet() {
		localVarQueryParams.Add("noSketchGeometry", parameterToString(localVarOptionals.NoSketchGeometry.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtFeatureListResponse2457
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetPartStudioMassPropertiesOpts Optional parameters for the method 'GetPartStudioMassProperties'
type GetPartStudioMassPropertiesOpts struct {
    PartId optional.Interface
    MassAsGroup optional.Bool
    Configuration optional.String
    LinkDocumentId optional.String
}

/*
GetPartStudioMassProperties Mass properties of parts or a PartStudio.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did Document ID.
 * @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 * @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 * @param eid Element ID.
 * @param optional nil or *GetPartStudioMassPropertiesOpts - Optional Parameters:
 * @param "PartId" (optional.Interface of []string) -  IDs of the parts to retrieve. Repeat query param to add more than one (i.e. partId=JHK&partId=JHD). May not be combined with other ID filters
 * @param "MassAsGroup" (optional.Bool) -  If true, specified parts will be evaluated as a single object instead of individually
 * @param "Configuration" (optional.String) -  Configuration string.
 * @param "LinkDocumentId" (optional.String) -  Id of document that links to the document being accessed. This may provide additional access rights to the document. Allowed only with version (v) path parameter.
@return BtMassPropertiesBulkInfo
*/
func (a *PartStudiosApiService) GetPartStudioMassProperties(ctx _context.Context, did string, wvm string, wvmid string, eid string, localVarOptionals *GetPartStudioMassPropertiesOpts) (BtMassPropertiesBulkInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtMassPropertiesBulkInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/massproperties"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.PartId.IsSet() {
		t:=localVarOptionals.PartId.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("partId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("partId", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.MassAsGroup.IsSet() {
		localVarQueryParams.Add("massAsGroup", parameterToString(localVarOptionals.MassAsGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtMassPropertiesBulkInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetPartStudioNamedViewsOpts Optional parameters for the method 'GetPartStudioNamedViews'
type GetPartStudioNamedViewsOpts struct {
    SkipPerspective optional.Bool
    IncludeSectionCutViews optional.Bool
    LinkDocumentId optional.String
}

/*
GetPartStudioNamedViews Get Named Views
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did Document ID.
 * @param eid Element ID.
 * @param optional nil or *GetPartStudioNamedViewsOpts - Optional Parameters:
 * @param "SkipPerspective" (optional.Bool) -  Whether views with a perspective projection should be omitted.
 * @param "IncludeSectionCutViews" (optional.Bool) - 
 * @param "LinkDocumentId" (optional.String) - 
@return BtNamedViewsInfo
*/
func (a *PartStudiosApiService) GetPartStudioNamedViews(ctx _context.Context, did string, eid string, localVarOptionals *GetPartStudioNamedViewsOpts) (BtNamedViewsInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtNamedViewsInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/e/{eid}/namedViews"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.SkipPerspective.IsSet() {
		localVarQueryParams.Add("skipPerspective", parameterToString(localVarOptionals.SkipPerspective.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeSectionCutViews.IsSet() {
		localVarQueryParams.Add("includeSectionCutViews", parameterToString(localVarOptionals.IncludeSectionCutViews.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtNamedViewsInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetPartStudioShadedViewsOpts Optional parameters for the method 'GetPartStudioShadedViews'
type GetPartStudioShadedViewsOpts struct {
    ViewMatrix optional.String
    OutputHeight optional.Int32
    OutputWidth optional.Int32
    PixelSize optional.Float64
    Edges optional.String
    ShowAllParts optional.Bool
    IncludeSurfaces optional.Bool
    UseAntiAliasing optional.Bool
    Configuration optional.String
    LinkDocumentId optional.String
}

/*
GetPartStudioShadedViews Get Shaded Views
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did Document ID.
 * @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 * @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 * @param eid Element ID.
 * @param optional nil or *GetPartStudioShadedViewsOpts - Optional Parameters:
 * @param "ViewMatrix" (optional.String) -  12-number view matrix (comma-separated), or one of the following named views: top, bottom, front, back, left, right The 12 entries in the view matrix form three rows and four columns, which is a linear transformation applied to the model itself. The matrix's first three columns maps the coordinate axes of the model to the coordinate axes of the view, and the fourth column translates the origin (in meters). The view coordinates have x pointing right, y pointing up, and z pointing towards the viewer, while a front view of the model has x pointing right, y pointing away from the viewer, and z pointing up. For example, the identity matrix viewMatrix=1,0,0,0,0,1,0,0,0,0,1,0 corresponds to the top view, and viewMatrix=0.612,0.612,0,0,-0.354,0.354,0.707,0,0.707,-0.707,0.707,0 corresponds (approximately) to the isometric view. The first three columns of the view matrix should be orthonormal and have a positive determinant.  If this is not the case, view behavior may be undefined.
 * @param "OutputHeight" (optional.Int32) -  Output image height (in pixels)
 * @param "OutputWidth" (optional.Int32) -  Output image width (in pixels)
 * @param "PixelSize" (optional.Float64) -  Height and width represented by each pixel (in meters). If the value is 0, the display will be sized to fit the output image dimensions.
 * @param "Edges" (optional.String) -  The treatment to be applied to edges in the display. Options are show: show visible edges, hide: hide visible edges.
 * @param "ShowAllParts" (optional.Bool) -  Whether or not all parts should be shown in the element, regardless of user setting. If false, the visibility setting made by the user will be reflected in the image. If true, all parts will be shown.
 * @param "IncludeSurfaces" (optional.Bool) -  Whether or not surfaces should be shown in the element. It is applicable only when showAllParts is true. If false, surfaces will be excluded. If true, all surfaces will be shown.
 * @param "UseAntiAliasing" (optional.Bool) -  If true, an anti-aliasing factor will be used to smooth model boundaries in the final image result. If false, the image will be rasterized at the given resolution. Setting to true can have negative performance implications with respect to rendering time and memory usage. If a high-resolution image is requested and anti-aliasing is turned on, the server may not be able to fulfill the request.
 * @param "Configuration" (optional.String) -  Configuration string.
 * @param "LinkDocumentId" (optional.String) -  Id of document that links to the document being accessed. This may provide additional access rights to the document. Allowed only with version (v) path parameter.
@return BtShadedViewsInfo
*/
func (a *PartStudiosApiService) GetPartStudioShadedViews(ctx _context.Context, did string, wvm string, wvmid string, eid string, localVarOptionals *GetPartStudioShadedViewsOpts) (BtShadedViewsInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtShadedViewsInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/shadedviews"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ViewMatrix.IsSet() {
		localVarQueryParams.Add("viewMatrix", parameterToString(localVarOptionals.ViewMatrix.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OutputHeight.IsSet() {
		localVarQueryParams.Add("outputHeight", parameterToString(localVarOptionals.OutputHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OutputWidth.IsSet() {
		localVarQueryParams.Add("outputWidth", parameterToString(localVarOptionals.OutputWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PixelSize.IsSet() {
		localVarQueryParams.Add("pixelSize", parameterToString(localVarOptionals.PixelSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Edges.IsSet() {
		localVarQueryParams.Add("edges", parameterToString(localVarOptionals.Edges.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ShowAllParts.IsSet() {
		localVarQueryParams.Add("showAllParts", parameterToString(localVarOptionals.ShowAllParts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeSurfaces.IsSet() {
		localVarQueryParams.Add("includeSurfaces", parameterToString(localVarOptionals.IncludeSurfaces.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UseAntiAliasing.IsSet() {
		localVarQueryParams.Add("useAntiAliasing", parameterToString(localVarOptionals.UseAntiAliasing.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtShadedViewsInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetPartStudioTessellatedEdgesOpts Optional parameters for the method 'GetPartStudioTessellatedEdges'
type GetPartStudioTessellatedEdgesOpts struct {
    AngleTolerance optional.Float64
    ChordTolerance optional.Float64
    PartId optional.Interface
    EdgeId optional.Interface
    Configuration optional.String
    LinkDocumentId optional.String
}

/*
GetPartStudioTessellatedEdges Tesselated edges from a PartStudio.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
 * @param optional nil or *GetPartStudioTessellatedEdgesOpts - Optional Parameters:
 * @param "AngleTolerance" (optional.Float64) - 
 * @param "ChordTolerance" (optional.Float64) - 
 * @param "PartId" (optional.Interface of []string) - 
 * @param "EdgeId" (optional.Interface of []string) - 
 * @param "Configuration" (optional.String) - 
 * @param "LinkDocumentId" (optional.String) - 
@return BtExportTessellatedEdgesResponse327
*/
func (a *PartStudiosApiService) GetPartStudioTessellatedEdges(ctx _context.Context, did string, wvm string, wvmid string, eid string, localVarOptionals *GetPartStudioTessellatedEdgesOpts) (BtExportTessellatedEdgesResponse327, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtExportTessellatedEdgesResponse327
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/tessellatededges"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.AngleTolerance.IsSet() {
		localVarQueryParams.Add("angleTolerance", parameterToString(localVarOptionals.AngleTolerance.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChordTolerance.IsSet() {
		localVarQueryParams.Add("chordTolerance", parameterToString(localVarOptionals.ChordTolerance.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PartId.IsSet() {
		t:=localVarOptionals.PartId.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("partId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("partId", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.EdgeId.IsSet() {
		t:=localVarOptionals.EdgeId.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("edgeId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("edgeId", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtExportTessellatedEdgesResponse327
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetPartStudioTessellatedFacesOpts Optional parameters for the method 'GetPartStudioTessellatedFaces'
type GetPartStudioTessellatedFacesOpts struct {
    AngleTolerance optional.Float64
    ChordTolerance optional.Float64
    MaxFacetWidth optional.Float64
    OutputVertexNormals optional.Bool
    OutputFacetNormals optional.Bool
    OutputTextureCoordinates optional.Bool
    OutputFaceAppearances optional.Bool
    OutputIndexTable optional.Bool
    PartId optional.Interface
    FaceId optional.Interface
    OutputErrorFaces optional.Bool
    Configuration optional.String
    LinkDocumentId optional.String
    Body optional.String
}

/*
GetPartStudioTessellatedFaces Tesselated faces of the parts in the Part Studio.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
 * @param optional nil or *GetPartStudioTessellatedFacesOpts - Optional Parameters:
 * @param "AngleTolerance" (optional.Float64) - 
 * @param "ChordTolerance" (optional.Float64) - 
 * @param "MaxFacetWidth" (optional.Float64) - 
 * @param "OutputVertexNormals" (optional.Bool) - 
 * @param "OutputFacetNormals" (optional.Bool) - 
 * @param "OutputTextureCoordinates" (optional.Bool) - 
 * @param "OutputFaceAppearances" (optional.Bool) - 
 * @param "OutputIndexTable" (optional.Bool) - 
 * @param "PartId" (optional.Interface of []string) - 
 * @param "FaceId" (optional.Interface of []string) - 
 * @param "OutputErrorFaces" (optional.Bool) - 
 * @param "Configuration" (optional.String) - 
 * @param "LinkDocumentId" (optional.String) - 
 * @param "Body" (optional.String) - 
@return BtExportTessellatedFacesResponse898
*/
func (a *PartStudiosApiService) GetPartStudioTessellatedFaces(ctx _context.Context, did string, wvm string, wvmid string, eid string, localVarOptionals *GetPartStudioTessellatedFacesOpts) (BtExportTessellatedFacesResponse898, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtExportTessellatedFacesResponse898
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/tessellatedfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.AngleTolerance.IsSet() {
		localVarQueryParams.Add("angleTolerance", parameterToString(localVarOptionals.AngleTolerance.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChordTolerance.IsSet() {
		localVarQueryParams.Add("chordTolerance", parameterToString(localVarOptionals.ChordTolerance.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxFacetWidth.IsSet() {
		localVarQueryParams.Add("maxFacetWidth", parameterToString(localVarOptionals.MaxFacetWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OutputVertexNormals.IsSet() {
		localVarQueryParams.Add("outputVertexNormals", parameterToString(localVarOptionals.OutputVertexNormals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OutputFacetNormals.IsSet() {
		localVarQueryParams.Add("outputFacetNormals", parameterToString(localVarOptionals.OutputFacetNormals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OutputTextureCoordinates.IsSet() {
		localVarQueryParams.Add("outputTextureCoordinates", parameterToString(localVarOptionals.OutputTextureCoordinates.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OutputFaceAppearances.IsSet() {
		localVarQueryParams.Add("outputFaceAppearances", parameterToString(localVarOptionals.OutputFaceAppearances.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OutputIndexTable.IsSet() {
		localVarQueryParams.Add("outputIndexTable", parameterToString(localVarOptionals.OutputIndexTable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PartId.IsSet() {
		t:=localVarOptionals.PartId.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("partId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("partId", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.FaceId.IsSet() {
		t:=localVarOptionals.FaceId.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("faceId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("faceId", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.OutputErrorFaces.IsSet() {
		localVarQueryParams.Add("outputErrorFaces", parameterToString(localVarOptionals.OutputErrorFaces.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LinkDocumentId.IsSet() {
		localVarQueryParams.Add("linkDocumentId", parameterToString(localVarOptionals.LinkDocumentId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		localVarPostBody = localVarOptionals.Body.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtExportTessellatedFacesResponse898
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
TranslateIds Id Translations
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did Document ID.
 * @param wvm One of w or v or m corresponding to whether a workspace or version or microversion was entered.
 * @param wvmid Workspace (w), Version (v) or Microversion (m) ID.
 * @param eid Element ID.
 * @param btIdTranslationParams
@return BtIdTranslationInfo
*/
func (a *PartStudiosApiService) TranslateIds(ctx _context.Context, did string, wvm string, wvmid string, eid string, btIdTranslationParams BtIdTranslationParams) (BtIdTranslationInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtIdTranslationInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/idtranslations"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &btIdTranslationParams
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtIdTranslationInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// UpdateFeaturesOpts Optional parameters for the method 'UpdateFeatures'
type UpdateFeaturesOpts struct {
    Body optional.String
}

/*
UpdateFeatures Update Features
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did Document ID.
 * @param wid Workspace ID.
 * @param eid Element ID.
 * @param optional nil or *UpdateFeaturesOpts - Optional Parameters:
 * @param "Body" (optional.String) -  feature The serialized feature definition
@return BtUpdateFeaturesResponse1333
*/
func (a *PartStudiosApiService) UpdateFeatures(ctx _context.Context, did string, wid string, eid string, localVarOptionals *UpdateFeaturesOpts) (BtUpdateFeaturesResponse1333, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtUpdateFeaturesResponse1333
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/w/{wid}/e/{eid}/features/updates"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(wid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		localVarPostBody = localVarOptionals.Body.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtUpdateFeaturesResponse1333
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// UpdatePartStudioConfigurationOpts Optional parameters for the method 'UpdatePartStudioConfiguration'
type UpdatePartStudioConfigurationOpts struct {
    Body optional.String
}

/*
UpdatePartStudioConfiguration Update Configuration
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
 * @param optional nil or *UpdatePartStudioConfigurationOpts - Optional Parameters:
 * @param "Body" (optional.String) - 
@return BtConfigurationResponse2019
*/
func (a *PartStudiosApiService) UpdatePartStudioConfiguration(ctx _context.Context, did string, wvm string, wvmid string, eid string, localVarOptionals *UpdatePartStudioConfigurationOpts) (BtConfigurationResponse2019, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtConfigurationResponse2019
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/configuration"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(wvm, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(wvmid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		localVarPostBody = localVarOptionals.Body.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtConfigurationResponse2019
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// UpdatePartStudioFeatureOpts Optional parameters for the method 'UpdatePartStudioFeature'
type UpdatePartStudioFeatureOpts struct {
    Body optional.String
}

/*
UpdatePartStudioFeature Update Feature
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did Document ID.
 * @param wid Workspace ID.
 * @param eid Element ID.
 * @param fid The id of the feature being updated. This id should be URL encoded and must match the featureId found in the serialized structure
 * @param optional nil or *UpdatePartStudioFeatureOpts - Optional Parameters:
 * @param "Body" (optional.String) -  feature The serialized feature definition
@return BtFeatureDefinitionResponse1617
*/
func (a *PartStudiosApiService) UpdatePartStudioFeature(ctx _context.Context, did string, wid string, eid string, fid string, localVarOptionals *UpdatePartStudioFeatureOpts) (BtFeatureDefinitionResponse1617, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtFeatureDefinitionResponse1617
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(wid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"fid"+"}", _neturl.QueryEscape(parameterToString(fid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		localVarPostBody = localVarOptionals.Body.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtFeatureDefinitionResponse1617
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// UpdateRollbackOpts Optional parameters for the method 'UpdateRollback'
type UpdateRollbackOpts struct {
    Body optional.String
}

/*
UpdateRollback Update Feature Rollback
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did Document ID.
 * @param wid Workspace ID.
 * @param eid Element ID.
 * @param optional nil or *UpdateRollbackOpts - Optional Parameters:
 * @param "Body" (optional.String) -  The index at which the rollback index should be placed. Features  with entry index (0-based) higher than or equal to the value are rolled back. Value of -1 is treated  as an alias for \"end of feature list\". Otherwise the value must be in the range 0 to the number of  entries in the feature list
@return BtSetFeatureRollbackResponse1042
*/
func (a *PartStudiosApiService) UpdateRollback(ctx _context.Context, did string, wid string, eid string, localVarOptionals *UpdateRollbackOpts) (BtSetFeatureRollbackResponse1042, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BtSetFeatureRollbackResponse1042
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/partstudios/d/{did}/w/{wid}/e/{eid}/features/rollback"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(did, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(wid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=UTF-8; qs=0.09", "application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1", "application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		localVarPostBody = localVarOptionals.Body.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BtSetFeatureRollbackResponse1042
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
